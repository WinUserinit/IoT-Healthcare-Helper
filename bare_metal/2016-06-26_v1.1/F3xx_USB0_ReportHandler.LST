C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE F3XX_USB0_REPORTHANDLER
OBJECT MODULE PLACED IN F3xx_USB0_ReportHandler.OBJ
COMPILER INVOKED BY: c:\keil\C51\BIN\C51.exe F3xx_USB0_ReportHandler.c DB OE LARGE CD

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F3xx_USB0_ReportHandler.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2014
   5          //
   6          // Program Description:
   7          //
   8          // Contains functions and variables dealing with Input and Output HID reports.
   9          //
  10          //
  11          // FID:            3XX000007
  12          // Target:         C8051F340
  13          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
  14          //                 Silicon Laboratories IDE version 2.6
  15          // Project Name:   Generic HID Firmware
  16          //
  17          //
  18          // Release 1.0
  19          //      -140401 Initial Revision (Tushar Mazumder)
  20          //
  21          // OUT_REPORT_HANDLER may be modified to handle new features.
  22          
  23          // ----------------------------------------------------------------------------
  24          // Header files
  25          // ----------------------------------------------------------------------------
  26          
  27          // Project-level preprocessor #defines effective across all *.c files
  28          #include "ProjectDefines.h"
*** MESSAGE C286 IN LINE 169 OF ProjectDefines.h: writeReadHID() EP3OUT 256-byte buffer
*** MESSAGE C286 IN LINE 170 OF ProjectDefines.h: writeReadHID() EP3IN 256-byte buffer
*** MESSAGE C286 IN LINE 171 OF ProjectDefines.h: USB_EP_INDEX 3 for EP_STATUS[USB_EP_INDEX] and POLL_WRITE_BYTE (INDEX,
             - USB_EP_INDEX);
  29          
  30          // OS24EVK-58 Software Toolkit - bare metal device driver
  31          #if SUPPORT_MAX30100
              #include "max30100.h"
              #endif // SUPPORT_MAX30100
  34          
  35          // OS24EVK-58 Software Toolkit - bare metal device driver
  36          #if SUPPORT_MAX30101
  37          #include "max30101.h"
  38          #endif // SUPPORT_MAX30101
  39          
  40          // OS24EVK-58 Software Toolkit - bare metal device driver
  41          #if SUPPORT_LIS2DH
  42          #include "lis2dh.h"
  43          #endif // SUPPORT_LIS2DH
  44          
  45          // OS24EVK-58 Software Toolkit - bare metal device driver
  46          #if SUPPORT_MAX7311
              #include "max7311.h"
              #endif // SUPPORT_MAX7311
  49          
  50          #include "c8051f3xx.h" // not in SiLabs example for this file
  51          #include "F3xx_USB0_ReportHandler.h"
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 2   

  52          #include "F3xx_USB0_InterruptServiceRoutine.h"
  53          #include "F3xx_USB0_Descriptor.h"
  54          #include "F3xx_Initialize.h"
  55          
  56          
  57          // ----------------------------------------------------------------------------
  58          // Local Function Prototypes
  59          // ----------------------------------------------------------------------------
  60          
  61          void OUT_REPORT_HANDLER(int16_t internalCall);
  62          
  63          // ----------------------------------------------------------------------------
  64          // Global Variable Declaration
  65          // ----------------------------------------------------------------------------
  66          
  67          //#define DEBUGOS21     //verify the write/read ptr locations
  68          
  69          BufferStructure IO_BUFFER;
  70          
  71          sbit P20Btn = P2^0;     //   P2.0 = diagnostic pushbutton on C8051F321 daughtercard TOOLSTICK321DC (0=press
             -ed; 1=not pressed)
  72          sbit Led2 = P2^1;       //   P2.1 = diagnostic LED driver DS2 (1=light,0=dark)
  73          sbit Led1 = P2^2;       //   P2.2 = diagnostic LED driver DS1 (1=light,0=dark)
  74          sbit P23spare = P2^3;   //   P2.3 = spare, unconnected pin
  75          
  76          extern float gSMBusClkFreq;
  77          extern float gTimer1ClkFreq;
  78          extern float gSysClkFreq;
  79          extern uint8_t gI2Cflags;
  80          #ifdef EXPLICIT_REPORT_ID
  81          // OS24EVK-66 Firmware v1.1 2015-03-26 initial gOffset=1 EXPLICIT_REPORT_ID
  82          # if 0 // regression test
              uint8_t gOffset = 0; // EXPLICIT_REPORT_ID is defined
              # else
  85          uint8_t gOffset = 1; // EXPLICIT_REPORT_ID is defined
  86          # endif
  87          #else
              // OS24EVK-66 Firmware v1.1 2015-03-24 initial gOffset=0, but changed to 1 in OUT_REPORT_HANDLER() EXPLICI
             -T_REPORT_ID
              uint8_t gOffset = 0; // EXPLICIT_REPORT_ID is not defined
              #endif
  91          
  92          
  93          //------------------------------
  94          //
  95          // MAX30101 optical sensor device driver
  96          //
  97          //------------------------------
  98          
  99          uint8_t blockArr[192];
 100          uint8_t gOS21ready = 0; // TODO1: OS24EVK-66 could gOS21ready be a bit instead of uint8_t ? conserve xdata
             - space
 101          uint8_t gOS21numIntServiced = 0;
 102          #if SUPPORT_LIS2DH
 103          uint8_t gLIS2DHnumIntServiced = 0; // VERIFY: OS24EVK-66 global counter for lis2dh numReportsSent
 104          #endif // SUPPORT_LIS2DH
 105          
 106          // https://jira.maxim-ic.com/browse/OS24EVK-24 Refactor: HID report enum and wrappers
 107          // Add INT0Enable() firmware diagnostic to generate Mock HID reports:
 108          uint8_t gMockHIDFIFOChannels = 0;
 109          uint8_t gMockHIDFIFOChannel = 0;
 110          uint16_t gMockHIDFIFOCh1 = 0x100;
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 3   

 111          uint16_t gMockHIDFIFOCh2 = 0x200;
 112          uint16_t gMockHIDFIFOCh3 = 0x300;
 113          uint16_t gMockHIDFIFOCh4 = 0x400;
 114          #if SUPPORT_LIS2DH
 115          uint8_t gMockHIDreport2 = 0; // VERIFY: OS24EVK-66 firmware diagnostic Mock HID REPORT_ID(2)
 116          uint16_t gMockHID2X = 0x1020;
 117          uint16_t gMockHID2Y = 0x3040;
 118          uint16_t gMockHID2Z = 0x5060;
 119          #endif // SUPPORT_LIS2DH
 120          
 121          #if 1 // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
 122          uint8_t gLIS2DHready = 0;
 123          #endif // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
 124          
 125          
 126          // ----------------------------------------------------------------------------
 127          // External Function Prototypes
 128          // ----------------------------------------------------------------------------
 129          
 130          void i2c_write(uint8_t slaveAddress, uint8_t *pData, uint8_t lenData, uint8_t lenStartReg);
 131          void i2c_read(uint8_t slaveAddress, uint8_t *pData, uint8_t lenData, uint8_t lenStartReg);
 132          int16_t clearSDA(void);
 133          void Timer0_Init(uint8_t delayUnitsAreMicroseconds);
 134          void Timer1_Init(void);
 135          void Timer2_Init(void);
 136          void T0_Wait(uint16_t delayCount); // number of half-milliseconds or microseconds to wait, depending on pr
             -evious Timer0_Init(mode)
 137          #if SUPPORT_SPI
              void SPI_mode0(uint8_t, uint8_t, uint8_t, uint8_t*);
              void SPI_mode1(uint8_t, uint8_t*);
              void SPI_mode2(uint8_t, uint8_t*);
              #endif // SUPPORT_SPI
 142          
 143          // ----------------------------------------------------------------------------
 144          // OUT_REPORT_HANDLER()
 145          // ----------------------------------------------------------------------------
 146          // This handler processes the output report sent from the host.
 147          //-----------------------------------------------------------------------------
 148          void OUT_REPORT_HANDLER(int16_t internalCall) 
 149          {
 150   1              uint8_t temp;
 151   1      
 152   1      // VERIFY: OS24EVK-66 shouldn't gOffset initial value be 1 because of EXPLICIT_REPORT_ID ?
 153   1      // gOffset is never changed anywhere else; this should be the initial value.
 154   1      // OS24EVK-66 Firmware v1.1 2015-03-24 initial gOffset=0, but changed to 1 in OUT_REPORT_HANDLER() EXPLICI
             -T_REPORT_ID
 155   1      #ifdef EXPLICIT_REPORT_ID
 156   1              gOffset = 1;
 157   1      #endif
 158   1         // IO_BUFFER.Ptr[0] must be HID_REPORT_ID_1 OUT from host?
 159   1         
 160   1              switch (IO_BUFFER.Ptr[0+gOffset])
 161   1              {
 162   2                      case (0): //Firmware version  -- HRMonitorForm1.cs string HIDversion()
 163   2                              // read -- myHID.FirmwareVersion(out bytVerMajor, out VerMinor, out verYearHundreds, out verYear, out v
             -erMonth, out verDay)
 164   2                              IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
 165   2                              IO_BUFFER.Ptr[0+gOffset] = 0; // error status
 166   2                              IO_BUFFER.Ptr[1+gOffset] = versionInfo.major;
 167   2                              IO_BUFFER.Ptr[2+gOffset] = versionInfo.minor;
 168   2                              IO_BUFFER.Ptr[3+gOffset] = (versionInfo.year & 0xFF00) >> 8;    // year is an int, but we can only send by
             -tes, so need to split it
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 4   

 169   2                              IO_BUFFER.Ptr[4+gOffset] = versionInfo.year & 0xFF;
 170   2                              IO_BUFFER.Ptr[5+gOffset] = versionInfo.month;
 171   2                              IO_BUFFER.Ptr[6+gOffset] = versionInfo.day;
 172   2                              SendPacket(); // no need to check for internal call since only the GUI will request a read through this
             - function
 173   2                              break;
 174   2                      case (1): //LED (C51F321 P2.2=red, P2.1=green)
 175   2                              switch (IO_BUFFER.Ptr[1+gOffset]) 
 176   2                              {
 177   3                                      case (0):       // write -- myHID.LEDSet(xxxxxxP22P21)
 178   3                                              Led2 = IO_BUFFER.Ptr[2+gOffset] & 1; // sbit Led2 = P2^1;
 179   3                                              Led1 = (IO_BUFFER.Ptr[2+gOffset] & 2) >> 1; // sbit Led1 = P2^2;
 180   3                                              break;
 181   3                                      case (1):       // read -- myHID.GPIOP0Get(out xxxxxxP06P07) Firmware 2015-04-28: GPIOP0Get(P0byte) for INT_
             -AC testing
 182   3                                              Timer0_Init(TIMER0_INIT_DELAY_HALFMS);
 183   3                                              T0_Wait(IO_BUFFER.Ptr[2+gOffset] * 256 + IO_BUFFER.Ptr[3+gOffset]);     // variable delay to check asynch
             -ronous read
 184   3                                              IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
 185   3                                              IO_BUFFER.Ptr[0+gOffset] = 0; // error status
 186   3                                              //~ IO_BUFFER.Ptr[1+gOffset] = ((P0 & 0x80) >> 7) + ((P0 & 0x40) >> 5);
 187   3                                              IO_BUFFER.Ptr[1+gOffset] = P0; // Why all the fuss about scrambling P0 bits? Can I see the P0.0 and P
             -0.1 interrupt pin states?
 188   3                                              SendPacket(); // no need to check for internal call since only the GUI will request a read through th
             -is function
 189   3                                              break;
 190   3                              }
 191   2                              break;
 192   2                      case (2): //GPIO configuration (C51F321 P1 and P2)
 193   2                              switch (IO_BUFFER.Ptr[1+gOffset]) 
 194   2                              {
 195   3                                      case (0):       // write -- myHID.GPIOP1P2ConfigSet(P1MDOUT, P2MDOUT, weakPullupDisable)
 196   3                                              P1MDOUT = IO_BUFFER.Ptr[2+gOffset];     // P1 push-pull (1) or open-collector (0)
 197   3                                              P2MDOUT = IO_BUFFER.Ptr[3+gOffset];     // P2 push-pull (1) or open-collector (0)
 198   3                                              (IO_BUFFER.Ptr[4+gOffset] & 1) ? (XBR1 |= 0x80) : (XBR1 &= 0x7F);       // weak pull up disable (open colle
             -ctor only); 1 disabled, 0 enabled
 199   3                                              break;
 200   3                                      case (1):       // read -- myHID.GPIOP1P2ConfigGet(out P1MDOUT, out P2MDOUT, out weakPullupDisable)
 201   3                                              IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
 202   3                                              IO_BUFFER.Ptr[0+gOffset] = 0; // error status                                   
 203   3                                              IO_BUFFER.Ptr[1+gOffset] = P1MDOUT;     // P1 push-pull (1) or open-collector (0)
 204   3                                              IO_BUFFER.Ptr[2+gOffset] = P2MDOUT;     // P2 push-pull (1) or open-collector (0)
 205   3                                              IO_BUFFER.Ptr[3+gOffset] = (XBR1 & 0x80) >> 7; // weakPullupDisable
 206   3                                              SendPacket(); // no need to check for internal call since only the GUI will request a read through th
             -is function
 207   3                                              break;
 208   3                              }
 209   2                              break;
 210   2                      case (3): //GPIO value (C51F321 P1 and P2)
 211   2                              switch (IO_BUFFER.Ptr[1+gOffset]) 
 212   2                              {
 213   3                                      case (0):       // write -- myHID.GPIOP1P2Out(P1, P2)
 214   3                                              P1 = IO_BUFFER.Ptr[2+gOffset];          // P1 HI (1) or LO (0); set P1==1 and P1MDOUT==1 for HI-Z
 215   3                                              P2 = IO_BUFFER.Ptr[3+gOffset];          // P2 HI (1) or LO (0); set P2==1 and P1MDOUT==2 for HI-Z
 216   3                                              break;
 217   3                                      case (1):       // read -- myHID.GPIOP1P2In(out P1, out P2)
 218   3                                              temp = XBR1;
 219   3                                              if (IO_BUFFER.Ptr[2+gOffset] & 1)       // enable weak pullups in case GP pins are open-collector and not c
             -onnected to anything (which would falsely give '0')
 220   3                                              {
 221   4                                                      XBR1 &= 0x7F;
 222   4                                                      Timer0_Init(TIMER0_INIT_DELAY_HALFMS);
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 5   

 223   4                                                      T0_Wait(2);
 224   4                                              }
 225   3                                              IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
 226   3                                              IO_BUFFER.Ptr[0+gOffset] = 0;           // error status
 227   3                                              IO_BUFFER.Ptr[1+gOffset] = P1;          // P1 HI (1) or LO (0)
 228   3                                              IO_BUFFER.Ptr[2+gOffset] = P2;          // P2 HI (1) or LO (0)
 229   3                                              XBR1 = temp;
 230   3                                              SendPacket(); // no need to check for internal call since only the GUI will request a read through th
             -is function
 231   3                                              break;
 232   3                              }
 233   2                              break;
 234   2                      case (4): //I2C configuration
 235   2                              switch (IO_BUFFER.Ptr[1+gOffset])
 236   2                              {
 237   3                                      case 0: // write -- myHID.I2CConfigSet(gI2Cflags, EXTHOLD, ClearSDAbyTogglingSCL)
 238   3                                              gI2Cflags = IO_BUFFER.Ptr[2+gOffset];
 239   3                                              // bit0 == 1: repeated start (versus stop/start) after write before read (applies to random read only
             -)
 240   3                                              // bit1 == 1: start random read with a write, but end the write right away without sending reg addres
             -s (emulate Jungo dongle for debug purposes)
 241   3                                              // bit2 == 1: repeat transaction if slave NACKs (suggest not to use this)
 242   3                                              // all flags are OR'd
 243   3                                              (IO_BUFFER.Ptr[3+gOffset] & 1) ? (SMB0CF |= 0x10) : (SMB0CF &= 0xEF);   // set EXTHOLD bit (SMBus setup
             - / hold time extension)
 244   3                                              if (IO_BUFFER.Ptr[4+gOffset] & 1)       // clear SDA by toggling SCL
 245   3                                              {
 246   4                                                      IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
 247   4                                                      IO_BUFFER.Ptr[0+gOffset] = 0;   // transaction error status
 248   4                                                      IO_BUFFER.Ptr[1+gOffset] = clearSDA();  // clearSDA error status
 249   4                                                      SendPacket();                   // send status of clearing SDA to host
 250   4                                              }
 251   3                                              break;
 252   3                                      case 1: //read -- myHID.I2CConfigGet(out config)
 253   3                                              IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
 254   3                                              IO_BUFFER.Ptr[0+gOffset] = 0; // error status                                   
 255   3                                              IO_BUFFER.Ptr[1+gOffset] = gI2Cflags;
 256   3                                              IO_BUFFER.Ptr[2+gOffset] = (SMB0CF & 0x10) >> 4; // EXTHOLD
 257   3                                              SendPacket(); // no need to check for internal call since only the GUI will request a read through th
             -is function
 258   3                                              break;
 259   3                              }
 260   2                              break;
 261   2                      case (5): //I2C clock rate (number of counts to overflow)
 262   2                              switch (IO_BUFFER.Ptr[1+gOffset])  
 263   2                              {
 264   3                                      case (0):       // write -- myHID.I2CClockSet(ReloadTH1)
 265   3                                              gSMBusClkFreq = gTimer1ClkFreq / 3.0 / IO_BUFFER.Ptr[2+gOffset];        //GUI sends the number of counts to 
             -overflow; HID must calculate the desired SMBus clock frequency
 266   3                                              TR1 = 0;
 267   3                                              Timer1_Init();
 268   3                                              break;
 269   3                                      case (1):       // read -- myHID.I2CClockGet(out TimerClockMHz, out ReloadTH1)
 270   3                                              IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
 271   3                                              IO_BUFFER.Ptr[0+gOffset] = 0; // error status
 272   3                                              IO_BUFFER.Ptr[1+gOffset] = gTimer1ClkFreq / 1000000 / 3;        //return the SMBus timer's clock frequency (
             -in MHz)
 273   3                                              IO_BUFFER.Ptr[2+gOffset] = 256-TH1;                                             //and return the SMBus timer's count value in order to calcu
             -late the SMBus clock frequency; TH1 is the reload value that gets loaded into TL0 upon overflow; the reload value is 256
             --TH1 since (0)-TH1 gives the proper number of counts to overflow
 274   3                                              SendPacket(); // no need to check for internal call since only the GUI will request a read through th
             -is function
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 6   

 275   3                                              break;
 276   3                              }
 277   2                              break;
 278   2                      case (6):       // I2C transaction -- HID.cs void writeI2C() readI2C()
 279   2                              switch (IO_BUFFER.Ptr[1+gOffset] & 1)
 280   2                              {
 281   3                                      case (0):       // write -- myHID.I2CWrite(deviceAddress, numDataBytes, numRegBytes, data[], reg[], ignoreNA
             -CK)
 282   3                                              i2c_write(/* slaveAddress */ IO_BUFFER.Ptr[1+gOffset] & 0xFE, /* uint8_t *pData */ IO_BUFFER.Ptr, /* 
             -lenData */ IO_BUFFER.Ptr[2+gOffset], /* lenStartReg */ IO_BUFFER.Ptr[3+gOffset]); 
 283   3                                              // note that start register address & data start at IO_BUFFER.Ptr[4]
 284   3                                              break;
 285   3                                      case (1):       // read -- myHID.I2CRead(deviceAddress, numDataBytes, numRegBytes, readData[], reg[], ignore
             -NACK)
 286   3                                              i2c_read(/* slaveAddress */ IO_BUFFER.Ptr[1+gOffset] & 0xFE, /* uint8_t *pData */ IO_BUFFER.Ptr, /* l
             -enData */ IO_BUFFER.Ptr[2+gOffset], /* lenStartReg */ IO_BUFFER.Ptr[3+gOffset]);
 287   3                                              // note that start register address starts at IO_BUFFER.Ptr[4]
 288   3                                              break;
 289   3                              }
 290   2                              if (!internalCall)
 291   2                                      SendPacket(); // don't send status to host if startup or switch is causing the I2C write
 292   2                              break;
 293   2                      case (7):       // SPI config
 294   2                              switch (IO_BUFFER.Ptr[1+gOffset]) //check if read (1) or write (0) 
 295   2                              {
 296   3                                      case (0):       // write -- myHID.SPIConfigSet(config)
 297   3      #if SUPPORT_SPI
                                                      SPI0CN &= 0xFE; // Disable SPI before setting clock phase and polarity
                                                      (IO_BUFFER.Ptr[2+gOffset] & 0x1) ? (SPI0CFG |= 0x10) : (SPI0CFG &= 0xEF);       // set CKPOL; 0 means idle 
             -LO
                                                      ((IO_BUFFER.Ptr[2+gOffset] & 0x2) >> 1) ? (SPI0CFG |= 0x20) : (SPI0CFG &= 0xDF);        // set CKPHA; 0 mean
             -s latch data when clock goes to the opposite polarity of idle
                                                      ((IO_BUFFER.Ptr[2+gOffset] & 0x4) >> 2) ? (SPI0CN |= 0x04) : (SPI0CN &= 0xFB);  // set NSSMD0
                                                      SPI0CN |= 0x01;
              #endif // SUPPORT_SPI
 304   3                                              break;
 305   3                                      case (1):       // read -- myHID.SPIConfigGet(out config)
 306   3      #if SUPPORT_SPI
                                                      IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
                                                      IO_BUFFER.Ptr[0+gOffset] = 0; // error status
                                                      IO_BUFFER.Ptr[1+gOffset] = ((SPI0CFG & 0x30) >> 4) + (SPI0CN & 4) ;     // return NSSMD0, CKPHA, CKPOL in
             - bits 2, 1, 0                                                                
              #else // SUPPORT_SPI
 311   3                                              IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
 312   3                                              IO_BUFFER.Ptr[0+gOffset] = 0xFA; // error status -- failure, SPI not supported
 313   3      #endif // SUPPORT_SPI
 314   3                                              SendPacket(); // no need to check for internal call since only the GUI will request a read through th
             -is function
 315   3                                              break;
 316   3                              }
 317   2                              break;
 318   2                      case (8):       // SPI clock rate
 319   2                              switch (IO_BUFFER.Ptr[1+gOffset]) //check if read (1) or write (0) 
 320   2                              {
 321   3                                      case (0):       // write -- myHID.SPIClockSet(SPI0CKR)
 322   3      #if SUPPORT_SPI
                                                      SPI0CKR = IO_BUFFER.Ptr[2+gOffset];
              #endif // SUPPORT_SPI
 325   3                                              break;
 326   3                                      case (1):       // read -- myHID.SPIClockGet(out SPI0CKR)
 327   3      #if SUPPORT_SPI
                                                      IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 7   

                                                      IO_BUFFER.Ptr[0+gOffset] = 0; // error status
                                                      IO_BUFFER.Ptr[1+gOffset] = gSysClkFreq / 1000000;                                       // return system clock freq (in MHz)
                                                      IO_BUFFER.Ptr[2+gOffset] = SPI0CKR;     // return SPI0CKR
              #else // SUPPORT_SPI
 333   3                                              IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
 334   3                                              IO_BUFFER.Ptr[0+gOffset] = 0xFA; // error status -- failure, SPI not supported
 335   3                                              IO_BUFFER.Ptr[1+gOffset] = gSysClkFreq / 1000000;                                       // return system clock freq (in MHz)
 336   3                                              IO_BUFFER.Ptr[2+gOffset] = SPI0CKR;     // return SPI0CKR
 337   3      #endif // SUPPORT_SPI
 338   3                                              SendPacket(); // no need to check for internal call since only the GUI will request a read through th
             -is function                
 339   3                                              break;
 340   3                              }
 341   2                              break;
 342   2                      case (9):       // SPI transaction
 343   2                              temp = IO_BUFFER.Ptr[2+gOffset];
 344   2                              switch (IO_BUFFER.Ptr[1+gOffset])       // SPI type 
 345   2                              {
 346   3      #if SUPPORT_SPI
                                              case (0):
                                                      // void SPI_mode0(uint8_t phase_change, uint8_t phase_change_byte, uint8_t num_bytes, uint8_t *dataPt
             -r)
                                                      // IO_BUFFER.Ptr[1+gOffset] -- 0 for SPI_mode0: multi-byte SPI transfer.
                                                      // IO_BUFFER.Ptr[2+gOffset] -- not used
                                                      // IO_BUFFER.Ptr[3+gOffset] -- phase_change // !=0 enable changing the clock phase. some slaves chang
             -e phase between write/read
                                                      // IO_BUFFER.Ptr[4+gOffset] -- phase_change_byte // byte index where phase change should happen
                                                      // IO_BUFFER.Ptr[5+gOffset] -- num_bytes
                                                      // IO_BUFFER.Ptr[6+gOffset] -- not used
                                                      // IO_BUFFER.Ptr[7+gOffset] -- first byte of data starts on the (7 + offset) byte
                                                      SPI_mode0(IO_BUFFER.Ptr[3+gOffset], IO_BUFFER.Ptr[4+gOffset], IO_BUFFER.Ptr[5+gOffset], IO_BUFFER.Ptr
             -);
                                                      break;
                                              case (1):
                                                      // IO_BUFFER.Ptr[1+gOffset] -- 1 for SPI_mode1: two-byte SPI transfer. read flag: enable changing the
             - clock phase on first byte and changing phase between first and second byte
                                                      // IO_BUFFER.Ptr[2+gOffset] -- read flag
                                                      // IO_BUFFER.Ptr[3+gOffset] -- not used
                                                      // IO_BUFFER.Ptr[4+gOffset] -- not used
                                                      // IO_BUFFER.Ptr[5+gOffset] -- not used; num_bytes = 2
                                                      // IO_BUFFER.Ptr[6+gOffset] -- not used
                                                      // IO_BUFFER.Ptr[7+gOffset] -- first byte of data starts on the (7 + offset) byte
                                                      SPI_mode1(temp, IO_BUFFER.Ptr);
                                                      break;
                                              case (2):
                                                      // IO_BUFFER.Ptr[1+gOffset] --2 for SPI_mode2: two-byte SPI transfer. read flag: enable changing the 
             -clock phase on first byte and sampling the LSb after the second byte read
                                                      // IO_BUFFER.Ptr[2+gOffset] -- read flag
                                                      // IO_BUFFER.Ptr[3+gOffset] -- not used
                                                      // IO_BUFFER.Ptr[4+gOffset] -- not used
                                                      // IO_BUFFER.Ptr[5+gOffset] -- not used; num_bytes = 2
                                                      // IO_BUFFER.Ptr[6+gOffset] -- not used
                                                      // IO_BUFFER.Ptr[7+gOffset] -- first byte of data starts on the (7 + offset) byte
                                                      SPI_mode2(temp, IO_BUFFER.Ptr);
                                                      break;
              #endif // SUPPORT_SPI
 379   3                              }
 380   2                              if (!internalCall && temp)
 381   2                                      SendPacket();
 382   2                              break;
 383   2                      case (23): //enable INT0 -- HRMonitorForm1.cs WriteOS24StartConfig()
 384   2                              // https://jira.maxim-ic.com/browse/OS24EVK-24 Refactor: HID report enum and wrappers
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 8   

 385   2                              // Add INT0Enable() firmware diagnostic to generate Mock HID reports
 386   2                              gMockHIDFIFOChannel = 0;
 387   2                              gMockHIDFIFOCh1 = 0x100;
 388   2                              gMockHIDFIFOCh2 = 0x200;
 389   2                              gMockHIDFIFOCh3 = 0x300;
 390   2                              gMockHIDFIFOCh4 = 0x400;
 391   2                              gOS21numIntServiced = 0;
 392   2      #if SUPPORT_LIS2DH
 393   2               gLIS2DHnumIntServiced = 0; // VERIFY: OS24EVK-66 global counter for lis2dh numReportsSent
 394   2               gMockHID2X = 0x1020;
 395   2               gMockHID2Y = 0x3040;
 396   2               gMockHID2Z = 0x5060;
 397   2      #endif // SUPPORT_LIS2DH
 398   2                              switch(IO_BUFFER.Ptr[1+gOffset])
 399   2                              {
 400   3                              case 0: //  -- myHID.INT0Enable(0) disabled (EX0=0)
 401   3                              case 1: //  -- myHID.INT0Enable(1) real hardware (EX0=1)
 402   3                              default:
 403   3                                      gMockHIDFIFOChannels = 0;
 404   3      #if SUPPORT_LIS2DH
 405   3                                      gMockHIDreport2 = 0; // VERIFY: OS24EVK-66 firmware diagnostic Mock HID REPORT_ID(2)
 406   3      #endif // SUPPORT_LIS2DH
 407   3                                      EX0 = IO_BUFFER.Ptr[1+gOffset]; // Enable INT0 interrupt
 408   3      #if SUPPORT_LIS2DH 
 409   3                  // TODO1: OS24EVK-66 INT0Enable() handler call lis2dh_configure_FIFO()
 410   3                  if (IO_BUFFER.Ptr[1+gOffset] == 0) {
 411   4                     //  -- myHID.INT0Enable(0) disabled (EX0=0)
 412   4                     lis2dh_configure_FIFO(/* fifoModeFM10 0:Bypass */ 0, /* fifoTR */ 0, /* fifoWatermarkLevelF
             -TH40 */ 0);
 413   4      #if 1 // TODO1: (Firmware 2015-04-26) OS24EVK-66 OS24EVK-83 configure LIS2DH
 414   4                     // TODO1: OS24EVK-66 OS24EVK-83 enable LIS2DH interrupt INT1: EX1 = 1
 415   4                     EX1 = 0;
 416   4      #endif // TODO1: (Firmware 2015-04-26) OS24EVK-66 OS24EVK-83 configure LIS2DH
 417   4                  }
 418   3                  else {
 419   4                     //  -- myHID.INT0Enable(1) real hardware (EX0=1)
 420   4      #if 0 // TODO1: (Firmware 2015-04-26) OS24EVK-66 OS24EVK-83 configure LIS2DH
                             // TODO: configure lis2dh_CTRL_REG1 without modifying ODR field
                             lis2dh_RegWrite(lis2dh_CTRL_REG1, 0x57); // magic? ODR=100Hz LPen=0 Zen=1 Yen=1 Xen=1
                             lis2dh_RegWrite(lis2dh_CTRL_REG2, 0x01); // magic? HPIS1=1
                             lis2dh_RegWrite(lis2dh_CTRL_REG3, 0x06); // magic? I1_WTM=1 I1_OVERRUN=1
                             lis2dh_RegWrite(lis2dh_CTRL_REG4, 0x88); // magic? BDU=1 FS=2G HR=1
                             lis2dh_RegWrite(lis2dh_CTRL_REG5, 0x01); // magic? FIFO_EN=0 D4D_INT2=1
                             //~ lis2dh_RegWrite(lis2dh_CTRL_REG6, 0x22); // magic? I2_INT2=1 H_LACTIVE=1
                             lis2dh_RegWrite(lis2dh_INT1_CFG, 0x7F); // magic? 6 direction movement recognition
                             lis2dh_RegWrite(lis2dh_INT1_THS, 0x04); // magic? threshold
                             lis2dh_RegWrite(lis2dh_INT1_DURATION, 0x00); // magic? duration
                             lis2dh_RegWrite(lis2dh_INT2_CFG, 0x7F); // magic? 6 direction movement recognition
                             lis2dh_RegWrite(lis2dh_INT2_THS, 0x04); // magic? threshold
                             lis2dh_RegWrite(lis2dh_INT2_DURATION, 0x00); // magic? duration
                             // TODO1: (2015-04-27) apparently reading INT1_SOURCE disrupts the accelerometer OUT_Y data
             - stream.
                             lis2dh_RegRead(lis2dh_INT1_SOURCE, 0 /* discard reg read value */ ); //!< clear INT by read
             -ing INT1_SRC register (read-only) 0 IA ZH ZL YH YL XH XL
              #endif // TODO1: (Firmware 2015-04-26) OS24EVK-66 OS24EVK-83 configure LIS2DH
 437   4      #if 1 // TODO: lis2dh_configure_FIFO(LIS2DH_DEFAULT_FIFOMODE) when max30101_RegWrite(RegAddressEnum.ModeCo
             -nfiguration,...)
 438   4      # ifdef LIS2DH_DEFAULT_FIFOMODE
 439   4                     lis2dh_configure_FIFO(/* fifoModeFM10 1:FIFO mode */ LIS2DH_DEFAULT_FIFOMODE, /* fifoTR */ 
             -0, LIS2DH_DEFAULT_FIFOWATERMARKLEVEL);
 440   4      # else
                             lis2dh_configure_FIFO(/* fifoModeFM10 1:FIFO mode */ 1, /* fifoTR */ 0, /* fifoWatermarkLev
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 9   

             -elFTH40 */ 0);
              # endif
 443   4      #endif // TODO: lis2dh_configure_FIFO(LIS2DH_DEFAULT_FIFOMODE) when max30101_RegWrite(RegAddressEnum.ModeC
             -onfiguration,...)
 444   4      //
 445   4      // (Sometimes)
 446   4      // (X) Missed first USB HID2 report. _lastHID1ReportCount=0, _lastHID2ReportCount=-0,
 447   4      // This report's numInterruptsServiced=1
 448   4      //
 449   4      // INT_AC duty cycle is low(active) most of the time. 
 450   4      // Should be briefly active while interrupt pending, then inactive(high) while FIFO is buffering.
 451   4      //
 452   4      // Why INT_AC stuck active(low) starting 150ms before first INT_OS pulse?
 453   4      // INT_AC goes low after write 0x2e FIFO_CTRL_REG with 0x8A 2:Stream Mode, watermark 10 samples
 454   4      // How long does it take before FIFO overrun?
 455   4      // With 0x2E=0x8A FIFO watermark level 10 and ODR 100Hz, overflow after 110ms 
 456   4      // With 0x2E=0x9F FIFO watermark level 32 and ODR 100Hz, overflow after 320ms 
 457   4      //
 458   4      //   LIS2DH.RegRead(0x20 CTRL_REG1, 0x57);
 459   4      //      ODR = 0x05(100 Hz), LPen = 0, Zen = 1, Yen = 1, Xen = 1
 460   4      //   LIS2DH.RegRead(0x21 CTRL_REG2, 0x00);
 461   4      //      HPM = 0 Normal, HPCF = 0, FDS = 0, HPCLICK = 0, HPIS2 = 0, HPIS1 = 0
 462   4      //   LIS2DH.RegRead(0x22 CTRL_REG3, 0x06);
 463   4      //      I1_CLICK = 0, I1_AOI1 = 0, I1_AOI2 = 0,
 464   4      //      I1_DRDY1 = 0, I1_DRDY2 = 0, I1_WTM = 1, I1_OVERRUN = 1
 465   4      //   LIS2DH.RegRead(0x23 CTRL_REG4, 0x88);
 466   4      //      BDU = 1, BLE = 0, FS = 0(±2G)
 467   4      //      HR = 1, ST1 = 0, ST0 = 0, SIM = 0
 468   4      //   LIS2DH.RegRead(0x24 CTRL_REG5, 0x48);
 469   4      //      BOOT = 0, FIFO_EN = 1
 470   4      //      LIR_INT1 = 1, D4D_INT1 = 0, LIR_INT2 = 0, D4D_INT2 = 0
 471   4      //   LIS2DH.RegRead(0x25 CTRL_REG6, 0x02);
 472   4      //      I2_CLICKen = 0, I2_INT1 = 0, I2_INT2 = 0, BOOT_I2 = 0
 473   4      //      P2_ACT = 0, H_LACTIVE = 1
 474   4      //   LIS2DH.RegRead(0x2e FIFO_CTRL_REG, 0x8a);
 475   4      //      FM = 2(Stream mode), TR = 0, FTH = 0x0a(level 10)
 476   4      //   LIS2DH.RegRead(0x2f FIFO_SRC_REG, 0xdf);
 477   4      //      WTM = 1, OVRN_FIFO = 1, EMPTY = 0, FSS = 0x1f(level 31)
 478   4      //   LIS2DH.RegRead(0x31 INT1_SOURCE, 0x00);
 479   4      //   LIS2DH.RegRead(0x35 INT2_SOURCE, 0x00);
 480   4      //
 481   4      #if 1 // TODO: lis2dh_configure_FIFO(LIS2DH_DEFAULT_FIFOMODE) when max30101_RegWrite(RegAddressEnum.ModeCo
             -nfiguration,...)
 482   4            // TODO1: (Firmware 2015-04-26) OS24EVK-66 OS24EVK-83 configure LIS2DH
 483   4                     // TODO1: OS24EVK-66 OS24EVK-83 enable LIS2DH interrupt INT1: EX1 = 1
 484   4                     EX1 = 1;
 485   4      #endif // TODO1: (Firmware 2015-04-26) OS24EVK-66 OS24EVK-83 configure LIS2DH
 486   4                  }
 487   3      #endif
 488   3                                      break;
 489   3                              case 2: //  -- myHID.INT0Enable(2) Mock HID x1 channel    101, 102, 103, ...
 490   3                                      gMockHIDFIFOChannels = 1;
 491   3                                      EX0 = 1; // Enable INT0 interrupt
 492   3                                      break;
 493   3                              case 3: //  -- myHID.INT0Enable(3) Mock HID x2 channels   101, 201, 102, 202, 103, 203, ...
 494   3                                      gMockHIDFIFOChannels = 2;
 495   3                                      EX0 = 1; // Enable INT0 interrupt
 496   3                                      break;
 497   3                              case 4: //  -- myHID.INT0Enable(4) Mock HID x3 channels   101, 201, 301, 102, 202, 302, 103, 203, 303, 
             -...
 498   3                                      gMockHIDFIFOChannels = 3;
 499   3                                      EX0 = 1; // Enable INT0 interrupt
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 10  

 500   3                                      break;
 501   3                              case 5: //  -- myHID.INT0Enable(5) Mock HID x4 channels   101, 201, 301, 401, 102, 202, 302, 402, 103, 
             -203, 303, 403, ...
 502   3                                      gMockHIDFIFOChannels = 4;
 503   3                                      EX0 = 1; // Enable INT0 interrupt
 504   3                                      break;
 505   3      #if SUPPORT_LIS2DH
 506   3                              case 6: //  -- myHID.INT0Enable(6) Mock HID REPORT_ID(2) x3 channels (X,Y,Z) 101, 201, 301, 102, 202, 3
             -02, 103, 203, 303, ...
 507   3                                      gMockHIDreport2 = 1; // VERIFY: OS24EVK-66 firmware diagnostic Mock HID REPORT_ID(2)
 508   3                                      EX0 = 1; // Enable INT0 interrupt
 509   3                                      break;
 510   3      #endif // SUPPORT_LIS2DH
 511   3                              }
 512   2                              break;
 513   2              }
 514   1      }
 515          
 516          void Setup_IO_BUFFER(void)
 517          {
 518   1         IO_BUFFER.Ptr = IO_PACKET;
 519   1      #ifdef EXPLICIT_REPORT_ID
 520   1              IO_BUFFER.Length = 64;
 521   1      #else   
                      IO_BUFFER.Length = SHORT_REPORT_COUNT;
              #endif
 524   1      }
 525          
 526          //-----------------------------------------------------------------------------
 527          // External Interrupt 0 Interrupt Service Routine (ISR)
 528          //-----------------------------------------------------------------------------
 529          // MAX30101 Optical Sensor interrupt
 530          //   P0.1 = MAX30101 INT (INT0 interrupt source)
 531          //
 532          void INT0_ISR (void) interrupt INTERRUPT_INT0 /* interrupt 0 */       // INT0 ISR
 533          {
 534   1              gOS21ready = 1;
 535   1      #if 1 // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
 536   1         // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
 537   1         gLIS2DHready = 1;
 538   1      #endif // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
 539   1      }
 540          
 541          //-----------------------------------------------------------------------------
 542          // External Interrupt 1 Interrupt Service Routine (ISR)
 543          //-----------------------------------------------------------------------------
 544          // Accelerometer interrupt
 545          //   P0.0 = Accelerometer INT (optional INT1 interrupt source)
 546          //
 547          #if SUPPORT_LIS2DH
 548          void INT1_ISR (void) interrupt INTERRUPT_INT1 /* interrupt 2 */
 549          {
 550   1         // OS24EVK-66 stub ISR for INT2 (C8051F321 P0.0 = STMicro LIS2DH INT1)
 551   1         
 552   1         // Either MAX30101 or Accelerometer interrupt,
 553   1         // will both trigger the same interrupt service routine
 554   1         // which reads the FIFO contents of both devices.
 555   1      #if 1 // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
 556   1         // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
 557   1         gLIS2DHready = 1;
 558   1      #else // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
                      gOS21ready = 1;
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 11  

              #endif // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
 561   1      
 562   1      }
 563          #endif // SUPPORT_LIS2DH
 564          
 565          void testOS21IntTiming()
 566          {
 567   1      #if SUPPORT_LIS2DH
 568   1              // uint8_t inner; // warning: unreferenced local variable
 569   1      #else
                      uint8_t inner; // warning: unreferenced local variable
              #endif
 572   1              uint8_t outer;
 573   1              gOS21ready = 0;
 574   1              // clear interrupts (not checking brownout)
 575   1              blockArr[5] = 0;        // int
 576   1              i2c_read(gMAX30101deviceAddress & 0xFE, blockArr, 1, 1);
 577   1              blockArr[5] = 5;
 578   1              for (outer=0; outer<60; outer++) {
 579   2                      i2c_read(gMAX30101deviceAddress & 0xFE, blockArr, 1, 1);
 580   2              }
 581   1              SendPacket();
 582   1      }
 583          
 584          //-----------------------------------------------------------------------------
 585          // Either MAX30101 or Accelerometer interrupt,
 586          // will both trigger the same interrupt service routine
 587          // which reads the FIFO contents of both devices.
 588          //
 589          // LIS2DH and MAX30101 internal clocks are not synchronous, so could have different FIFO levels.
 590          // Algorithms will low-pass filter etc. so don't care if output data rates are not exactly equal/synchrono
             -us.
 591          //
 592          void readOS21()
 593          {
 594   1         // MAX30101: each sample is 3 bytes per channel
 595   1      #define MAX30101_Bytes_Per_Channel 3
 596   1              uint8_t inner;
 597   1              uint8_t outer;
 598   1              uint8_t ptrDelta;
 599   1         // VERIFY: OS24EVK-72 HID report 1 byte 3 = MAX30101_InterruptStatus1 (not MAX30101_OverFlowCounter)
 600   1              // uint8_t ovf;
 601   1         uint8_t MAX30101_InterruptStatus1_value;
 602   1              uint8_t bytesRemaining;
 603   1              bit singleSample = 0;
 604   1              bit singleReport = 1;   // only return 60 bytes (10x 3-byte red and IR samples)
 605   1      #if SUPPORT_MAX30101
 606   1         // VERIFY: OS24EVK-66 Replace int with uint8_t where applicable; conserve xdata space
 607   1         uint8_t numBytesToRequestFromOpticalFIFO;
 608   1      #else
                 #define numBytesToRequestFromOpticalFIFO \
                 (singleSample                                            \
                    ? (2 * MAX30101_Bytes_Per_Channel)                    \
                    : (singleReport                                       \
                       ? (2 * MAX30101_Bytes_Per_Channel * 10)            \
                       : (ptrDelta * 2 * MAX30101_Bytes_Per_Channel)      \
                       )                                                  \
                    )
              
              #endif // SUPPORT_MAX30101
 619   1      #if 0 // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
              #if 1 // OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 12  

                 // TODO1: OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA new data available when reading X,Y,Z
                 uint8_t lis2dh_STATUS_REG2_value = 0; //!< (read-only) ZYXOR ZOR YOR XOR ZYXDA ZDA YDA XDA
              #if 1 // OS24EVK-66 Firmware regresssion 2015-04-16_v1.1 (svn r=15232) vs 2015-04-15_v1.1 (svn r=15222): c
             -rashes GUI and Console program on connect (API ReadFile error).
                 // 2015-04-22 Yikes! This declaration alone is enough to break it.
                 // Are we overloading some internal resource?
                 // 2015-04-23 restored lis2dh_FIFO_SRC_REG_value, after compacting xdata by 6 bytes...
                 //   2015-04-15_v1.1 (svn r=15222) Program Size: data=10.5 xdata=484 code=12705
                 //   2015-04-16_v1.1 (svn r=15306) Program Size: data=10.5 xdata=478 code=12687
                 // So that could mean the dragon still lurks, 5 bytes away...
                 uint8_t lis2dh_FIFO_SRC_REG_value /* = 0 */ ; //!< (read-only) WTM OVRN_FIFO EMPTY FSS4 FSS3 FSS2 FSS1 
             -FSS0
              #endif // OS24EVK-66 Firmware regresssion 2015-04-16_v1.1 (svn r=15232) vs 2015-04-15_v1.1 (svn r=15222): 
             -crashes GUI and Console program on connect (API ReadFile error).
              #endif // OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA
              #endif // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
 634   1         //
 635   1         // C not C++, so all local variables must be declared before any statements
 636   1         //
 637   1              if (singleSample) {
 638   2                      singleReport = 1;       //singleSample must be in a singleReport
 639   2              }
 640   1              gOS21ready = 0;
 641   1              // clear interrupts (not checking brownout)
 642   1         
 643   1      #if SUPPORT_MAX30101
 644   1         numBytesToRequestFromOpticalFIFO = (singleSample 
 645   1            ? (2 * MAX30101_Bytes_Per_Channel) 
 646   1            : (singleReport 
 647   1               ? (2 * MAX30101_Bytes_Per_Channel * 10) 
 648   1               : (ptrDelta * 2 * MAX30101_Bytes_Per_Channel)
 649   1               )
 650   1            );
 651   1      #endif // SUPPORT_MAX30101
 652   1              
 653   1      #if SUPPORT_MAX30101
 654   1         // read MAX30101 FIFO into blockArr[2..]
 655   1         if (gMAX30101deviceAddress != 0) {
 656   2      # if 0
              // TODO1: OS24EVK-66 i2c_smbus_read_bytes_data not working?
                    // I2C Burst Read starting from Device Register 0, length 2
                    //        Device Register 0 MAX30101_InterruptStatus1
                    //        Device Register 1 MAX30101_InterruptStatus2
                    i2c_smbus_read_bytes_data(
                       /* uint8_t deviceAddress */ gMAX30101deviceAddress, 
                       /* uint8_t regAddress */ MAX30101_InterruptStatus1, 
                       /* uint8_t count */ 2, 
                       /* uint8_t *pRegValue */ 0);
                    
                    // I2C Burst Read starting from Device Register 4, length 3
                    //        Device Register 4 MAX30101_FIFOWritePointer
                    //        Device Register 5 MAX30101_OverFlowCounter
                    //        Device Register 6 MAX30101_FIFOReadPointer
                    i2c_smbus_read_bytes_data(
                       /* uint8_t deviceAddress */ gMAX30101deviceAddress, 
                       /* uint8_t regAddress */ MAX30101_FIFOWritePointer, 
                       /* uint8_t count */ 3, 
                       /* uint8_t *pRegValue */ 0);
              # else
 677   2            // I2C Burst Read starting from Device Register 0, length 1
 678   2            //        Device Register 0 Interrupt Status 1
 679   2            blockArr[5] = MAX30101_InterruptStatus1;  // int MAX30101_InterruptStatus1
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 13  

 680   2            i2c_read(gMAX30101deviceAddress & 0xFE, blockArr, 2, 1);  
 681   2            // VERIFY: OS24EVK-72 HID report 1 byte 3 = MAX30101_InterruptStatus1 (not MAX30101_OverFlowCounter)
 682   2            MAX30101_InterruptStatus1_value = blockArr[2+0];
 683   2              
 684   2            // I2C Burst Read starting from Device Register 4, length 3
 685   2            //        Device Register 4 FIFO Write Pointer
 686   2            //        Device Register 5 Overflow Counter
 687   2            //        Device Register 6 FIFO Read Pointer
 688   2            blockArr[5] = 4;  // write ptr, ovf, read ptr
 689   2            i2c_read(gMAX30101deviceAddress & 0xFE, blockArr, 3, 1);  
 690   2      # endif
 691   2            // reg0x08 sets the number of empty FIFO slots (in 32 sample FIFO) until interrupt. 
 692   2            // If reg0x08=0, then on the 1st iteration, the writeptr will wrap back to 0, which is where the rea
             -dptr is. ptrdelta=0.
 693   2            // If reg0x08=1, then on the 1st iteration, the writeptr will be 31 and readptr=0. ptrdelta=31.
 694   2            // 
 695   2            //        blockArr[2+0] = value read from Device Register 4 FIFO Write Pointer
 696   2            //        blockArr[2+1] = value read from Device Register 5 Overflow Counter
 697   2            //        blockArr[2+2] = value read from Device Register 6 FIFO Read Pointer
 698   2            ptrDelta = (blockArr[2+0] - blockArr[2+2])&0x1F;  // FIFO ptrs are 5 bits, but HID can only read 10 s
             -amples per report
 699   2            // VERIFY: OS24EVK-72 HID report 1 byte 3 = MAX30101_InterruptStatus1 (not MAX30101_OverFlowCounter)
 700   2            //ovf = blockArr[2+1]; // value read from Device Register 5 MAX30101_OverFlowCounter
 701   2            
 702   2            // I2C Burst Read starting from Device Register 7, length (singleSample ? (6) : (singleReport ? (60)
             - : (ptrDelta * 6)))
 703   2            //        Device Register 7 FIFO Data Register
 704   2            //        This register streams out FIFO data, without auto-incrementing i2c register address
 705   2            blockArr[5] = 7; // Device Register 7 FIFO Data Register
 706   2            //FIXME must use block read on FIFO as follows otherwise data is corrupted
 707   2            i2c_read(
 708   2               /* slaveAddress */ (gMAX30101deviceAddress & 0xFE), 
 709   2               /* uint8_t *pData */ blockArr, 
 710   2               /* lenData */ numBytesToRequestFromOpticalFIFO, 
 711   2               /* lenStartReg */ 1);
 712   2         }
 713   1      #else // SUPPORT_MAX30101
                    // I2C Burst Read starting from Device Register 0, length 1
                    //        Device Register 0 Interrupt Status 1
                    blockArr[5] = 0;  // int
                    i2c_read(gMAX30101deviceAddress & 0xFE, blockArr, 2, 1);  
                      
                    // I2C Burst Read starting from Device Register 4, length 3
                    //        Device Register 4 FIFO Write Pointer
                    //        Device Register 5 Overflow Counter
                    //        Device Register 6 FIFO Read Pointer
                    blockArr[5] = 4;  // write ptr, ovf, read ptr
                    i2c_read(gMAX30101deviceAddress & 0xFE, blockArr, 3, 1);  
                    // reg0x08 sets the number of empty FIFO slots (in 32 sample FIFO) until interrupt. 
                    // If reg0x08=0, then on the 1st iteration, the writeptr will wrap back to 0, which is where the rea
             -dptr is. ptrdelta=0.
                    // If reg0x08=1, then on the 1st iteration, the writeptr will be 31 and readptr=0. ptrdelta=31.
                    // 
                    //        blockArr[2+0] = value read from Device Register 4 FIFO Write Pointer
                    //        blockArr[2+1] = value read from Device Register 5 Overflow Counter
                    //        blockArr[2+2] = value read from Device Register 6 FIFO Read Pointer
                    ptrDelta = (blockArr[2+0] - blockArr[2+2])&0x1F;  // FIFO ptrs are 5 bits, but HID can only read 10 s
             -amples per report
                    ovf = blockArr[2+1]; // value read from Device Register 5 MAX30101_OverFlowCounter
                    
                    // I2C Burst Read starting from Device Register 7, length (singleSample ? (6) : (singleReport ? (60)
             - : (ptrDelta * 6)))
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 14  

                    //        Device Register 7 FIFO Data Register
                    //        This register streams out FIFO data, without auto-incrementing i2c register address
                    blockArr[5] = 7; // Device Register 7 FIFO Data Register
                    //FIXME must use block read on FIFO as follows otherwise data is corrupted
                    i2c_read(
                       /* slaveAddress */ (gMAX30101deviceAddress & 0xFE), 
                       /* uint8_t *pData */ blockArr, 
                       /* lenData */ numBytesToRequestFromOpticalFIFO, 
                       /* lenStartReg */ 1);
              #endif // SUPPORT_MAX30101
 746   1              // firmware diagnostic to generate Mock HID REPORT_ID(1) data
 747   1              if (gMockHIDFIFOChannels > 0) {
 748   2                      // Add INT0Enable() firmware diagnostic to generate Mock HID reports
 749   2                      // Overwrite blockArr[2+inner...] with specified Mock data for testing
 750   2                      // INT0Enable(2) Mock HID x1 channel    101, 102, 103, ...
 751   2                      // INT0Enable(3) Mock HID x2 channels   101, 201, 102, 202, 103, 203, ...
 752   2                      // INT0Enable(4) Mock HID x3 channels   101, 201, 301, 102, 202, 302, 103, 203, 303, ...
 753   2                      //
 754   2                      // OS24EVK-29 Erroneous FIFO data readout in LED mode (Green)
 755   2                      // Based on what the chip actually does, it appears that in LED 3-channel mode
 756   2                      // where the HID report can only hold 6 and 2/3 samples, we end up
 757   2                      // overlapping (resending) the 2/3 partial sample in the next report.
 758   2                      // Based on the preliminary data sheet, I expected the partial sample readout
 759   2                      // would have incremented the FIFO read pointer, but apparently not. That's good!
 760   2                      // So change the mock HID diagnostic to match what the part actually does.
 761   2                      gMockHIDFIFOChannel  = 0;
 762   2                      //
 763   2                      for (inner = 0; inner < numBytesToRequestFromOpticalFIFO; inner += MAX30101_Bytes_Per_Channel) {
 764   3                              switch(gMockHIDFIFOChannel) {
 765   4                                      case 0:
 766   4                                              gMockHIDFIFOCh1++;
 767   4                                              blockArr[2+inner] = 0; // (gMockHIDFIFOCh1 >>16) & 0xFF; // High byte
 768   4                                              blockArr[3+inner] = (gMockHIDFIFOCh1 >> 8) & 0xFF; // Mid byte
 769   4                                              blockArr[4+inner] = (gMockHIDFIFOCh1 >> 0) & 0xFF; // Low byte
 770   4                                              break;
 771   4                                      case 1:
 772   4                                              gMockHIDFIFOCh2++;
 773   4                                              blockArr[2+inner] = 0; // (gMockHIDFIFOCh2 >>16) & 0xFF; // High byte
 774   4                                              blockArr[3+inner] = (gMockHIDFIFOCh2 >> 8) & 0xFF; // Mid byte
 775   4                                              blockArr[4+inner] = (gMockHIDFIFOCh2 >> 0) & 0xFF; // Low byte
 776   4                                              break;
 777   4                                      case 2:
 778   4                                              gMockHIDFIFOCh3++;
 779   4                                              blockArr[2+inner] = 0; // (gMockHIDFIFOCh3 >>16) & 0xFF; // High byte
 780   4                                              blockArr[3+inner] = (gMockHIDFIFOCh3 >> 8) & 0xFF; // Mid byte
 781   4                                              blockArr[4+inner] = (gMockHIDFIFOCh3 >> 0) & 0xFF; // Low byte
 782   4                                              break;
 783   4                                      case 3:
 784   4                                              gMockHIDFIFOCh4++;
 785   4                                              blockArr[2+inner] = 0; // (gMockHIDFIFOCh4>>16) & 0xFF; // High byte
 786   4                                              blockArr[3+inner] = (gMockHIDFIFOCh4 >> 8) & 0xFF; // Mid byte
 787   4                                              blockArr[4+inner] = (gMockHIDFIFOCh4 >> 0) & 0xFF; // Low byte
 788   4                                              break;
 789   4                              }
 790   3                              // gMockHIDFIFOChannel = (gMockHIDFIFOChannel + 1) % gMockHIDFIFOChannels;
 791   3                              gMockHIDFIFOChannel = gMockHIDFIFOChannel + 1;
 792   3                              if (gMockHIDFIFOChannel >= gMockHIDFIFOChannels) {
 793   4                                      gMockHIDFIFOChannel  = 0;
 794   4                              }
 795   3                      }
 796   2              }
 797   1              //
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 15  

 798   1         // Send HID REPORT_ID(1) from blockArr[2..]
 799   1      #if SUPPORT_MAX30101
 800   1         // TODO1: OS24EVK-66 if MAX30101 absent but (gMockHIDFIFOChannels > 0), still send HID report 1
 801   1         if (gMAX30101deviceAddress == 0) 
 802   1         {
 803   2            ptrDelta = 26; // mock value number of samples
 804   2            gMockHIDFIFOChannels = 3;
 805   2         }
 806   1         if ((gMAX30101deviceAddress != 0) || (gMockHIDFIFOChannels > 0)) 
 807   1      #else
                 // if (gMAX30101deviceAddress != 0) 
                 if (1) 
              #endif
 811   1         {
 812   2            // warning: if using ptrdelta to specify how many samples to read, do not read more than len(blockAr
             -r) bytes, otherwise memory access violation will occur
 813   2            //i2c_read(gMAX30101deviceAddress & 0xFE, blockArr, ptrDelta * 6, 1);
 814   2            IO_BUFFER.Ptr[0] = SHORT_REPORT_ID; // HID_REPORT_ID_1
 815   2            IO_BUFFER.Ptr[1] = gOS21numIntServiced++;
 816   2            IO_BUFFER.Ptr[2] = ptrDelta;
 817   2            // VERIFY: OS24EVK-72 HID report 1 byte 3 = MAX30101_InterruptStatus1 (not MAX30101_OverFlowCounter)
 818   2            IO_BUFFER.Ptr[3] = MAX30101_InterruptStatus1_value; // instead of ovf value read from Device Registe
             -r 5 MAX30101_OverFlowCounter
 819   2            for (inner=0; inner<(singleSample ? 6 : 60); inner++) {
 820   3               IO_BUFFER.Ptr[4+inner] = blockArr[2+inner];
 821   3            }
 822   2      // VERIFY: OS24EVK-66 USB_SUPPORT_SendPacketWaitEP1INready=1 SendPacketWaitEP1INready() as SendPacket() wi
             -th polling for INPRTY=0.
 823   2      #if USB_SUPPORT_SendPacketWaitEP1INready
 824   2            SendPacketWaitEP1INready();
 825   2      #else // USB_SUPPORT_SendPacketWaitEP1INready
                    SendPacket();
              #endif // USB_SUPPORT_SendPacketWaitEP1INready
 828   2            if (!singleReport)
 829   2            {
 830   3               if (ptrDelta == 0) {
 831   4                  ptrDelta = 32;
 832   4               }
 833   3               for (outer=0; outer<ptrDelta/10; outer++)      // integer division
 834   3               {
 835   4                  bytesRemaining = ptrDelta*6-(outer+1)*60;   // each full loop sends 60 bytes: (outer+1)*60
 836   4                  for (inner=0; inner<(bytesRemaining <= 60 ? bytesRemaining : 60); inner++) {
 837   5                     IO_BUFFER.Ptr[4+inner] = blockArr[2+inner+(outer+1)*60];
 838   5                  }
 839   4      // VERIFY: OS24EVK-66 USB_SUPPORT_SendPacketWaitEP1INready=1 SendPacketWaitEP1INready() as SendPacket() wi
             -th polling for INPRTY=0.
 840   4      #if USB_SUPPORT_SendPacketWaitEP1INready
 841   4                  SendPacketWaitEP1INready();
 842   4      #else // USB_SUPPORT_SendPacketWaitEP1INready
                          SendPacket();
              #endif // USB_SUPPORT_SendPacketWaitEP1INready
 845   4               }
 846   3            }
 847   2         }
 848   1         //
 849   1      #if 0 // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
                 // moved to readLIS2DH()
                 //
                 // VERIFY: OS24EVK-66 update *F3xx_USB0_ReportHandler.c* Interrupt Service Routine readOS21() to acquir
             -e accelerometer data and send a second HID report. 
                 //
              #if SUPPORT_LIS2DH
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 16  

                 // read LIS2DH FIFO into blockArr[2..]
              #define LIS2DH_Bytes_Per_Channel 2
                 if (gLIS2DHdeviceAddress != 0) {
                    // TODO: OS24EVK-66 read LIS2DH FIFO into blockArr[2..]
              #if 1
                    
                    // TODO: OS24EVK-66 HID2 LIS2DH ptrDelta = 0x2F FIFO_SRC_REG bits FFS4:0
                    lis2dh_RegRead(lis2dh_FIFO_SRC_REG, &lis2dh_FIFO_SRC_REG_value); //!< (read-only) WTM OVRN_FIFO EMPT
             -Y FSS4 FSS3 FSS2 FSS1 FSS0
                    // ptrDelta = (lis2dh_FIFO_SRC_REG_value & 0x1F);
                    ptrDelta = lis2dh_FIFO_SRC_REG_value; // diagnostic: give me all the 0x2F FIFO_SRC_REG bits 
                    
              #if 1 // OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA      
                    // TODO1: OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA new data available when reading X,
             -Y,Z
                    do {
                       lis2dh_RegRead(lis2dh_STATUS_REG2, &lis2dh_STATUS_REG2_value);
                    } while ((lis2dh_STATUS_REG2_value & 0x08) != 0x08);
              #endif // OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA
                    
                    // TODO1: OS24EVK-66 Read LIS2DH XYZ FIFO using a single 60-byte I2C read operation in readOS21() //
             - read LIS2DH FIFO into blockArr[2..]
                    #define numBytesToRequestFromLIS2DHFIFO 60
                    //        This register streams out FIFO data, without auto-incrementing i2c register address
                    blockArr[5] = lis2dh_OUT_X_L | 0x80; // start of FIFO register 
                    // 2015-04-16 OS24EVK-66 OS24EVK-57 LIS2DH multiple-byte read requires (regAddress | 0x80)
                    // LIS2DH data sheet pg 25 5.1.1 I2C operation (near last paragraph)
                    // In order to read multiple bytes, it is necessary to assert the most significant bit of the subadd
             -ress
                    // field. In other words, SUB(7) must be equal to 1 while SUB(6-0) represents the
                    // address of first register to be read.
                    //
                    // Note this raw XYZ data is LITTLE-ENDIAN (least significant byte first)
                    //
                    //FIXME must use block read on FIFO as follows otherwise data is corrupted
                    i2c_read(
                       /* slaveAddress */ (gLIS2DHdeviceAddress & 0xFE), 
                       /* uint8_t *pData */ blockArr, 
                       /* lenData */ numBytesToRequestFromLIS2DHFIFO, 
                       /* lenStartReg */ 1);
              #else
                    // mockup: read real X,Y,Z vector even if not from the FIFO
                    // VERIFY: OS24EVK-66 Restore the HID2 mock data diagnostic, verify no missing HID2 reports
                    lis2dh_Read_XYZ(&gMockHID2X, &gMockHID2Y, &gMockHID2Z);
                              for (inner=0; inner<(singleSample ? (6) : (singleReport ? (60) : (ptrDelta * 6))); inner += LIS2DH_Bytes
             -_Per_Channel) {
                                      switch(gMockHIDFIFOChannel) {
                                              case 0: // mock LIS2DH lis2dh_OUT_X_H,lis2dh_OUT_X_L
                                                      blockArr[2+inner] = (gMockHID2X >> 8) & 0xFF; // Mid byte
                                                      blockArr[3+inner] = (gMockHID2X >> 0) & 0xFF; // Low byte
                                                      break;
                                              case 1: // mock LIS2DH lis2dh_OUT_Y_H,lis2dh_OUT_Y_L
                                                      blockArr[2+inner] = (gMockHID2Y >> 8) & 0xFF; // Mid byte
                                                      blockArr[3+inner] = (gMockHID2Y >> 0) & 0xFF; // Low byte
                                                      break;
                                              case 2: // mock LIS2DH lis2dh_OUT_Z_H,lis2dh_OUT_Z_L
                                                      blockArr[2+inner] = (gMockHID2Z >> 8) & 0xFF; // Mid byte
                                                      blockArr[3+inner] = (gMockHID2Z >> 0) & 0xFF; // Low byte
                                                      break;
                                      }
                                      gMockHIDFIFOChannel = gMockHIDFIFOChannel + 1;
                                      if (gMockHIDFIFOChannel >= 3) {
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 17  

                                              gMockHIDFIFOChannel  = 0;
                          lis2dh_Read_XYZ(&gMockHID2X, &gMockHID2Y, &gMockHID2Z);
                                      }
                    }
              #endif
              
                    // TODO1: Reset LIS2DH INT_ACC interrupt by reading INT1_SOURCE register
                    // (2015-04-26) apparently reading INT1_SOURCE into lis2dh_FIFO_SRC_REG_value breaks the acceleromet
             -er data stream
                    //~ lis2dh_RegRead(lis2dh_INT1_SOURCE, &lis2dh_FIFO_SRC_REG_value); //!< clear INT by reading INT1_S
             -RC register (read-only) 0 IA ZH ZL YH YL XH XL
              #if 0 // TODO1: (Firmware 2015-04-26) OS24EVK-66 OS24EVK-83 configure LIS2DH
                    // TODO1: (2015-04-27) apparently reading INT1_SOURCE disrupts the accelerometer OUT_Y data stream.
                    lis2dh_RegRead(lis2dh_INT1_SOURCE, 0 /* discard reg read value */ ); //!< clear INT by reading INT1_
             -SRC register (read-only) 0 IA ZH ZL YH YL XH XL
              #endif // TODO1: (Firmware 2015-04-26) OS24EVK-66 OS24EVK-83 configure LIS2DH
              
                 }
                      // firmware diagnostic to generate Mock HID REPORT_ID(2) data
                      if (gMockHIDreport2 > 0) {
                    // TODO1: OS24EVK-66 firmware diagnostic Mock HID REPORT_ID(2) 
                              // Add INT0Enable() firmware diagnostic to generate Mock HID reports
                              // Overwrite blockArr[2+inner...] with specified Mock data for testing
                              // INT0Enable(6) Mock HID REPORT_ID(2) x3 channels (X,Y,Z) 101, 201, 301, 102, 202, 302, 103, 203, 303, 
             -...
                              //
                              gMockHIDFIFOChannel  = 0;
                              //
                              // LIS2DH: each sample is 2 bytes per channel
                              for (inner=0; inner<(singleSample ? (6) : (singleReport ? (60) : (ptrDelta * 6))); inner += LIS2DH_Bytes
             -_Per_Channel) {
                                      switch(gMockHIDFIFOChannel) {
                                              case 0: // mock LIS2DH lis2dh_OUT_X_H,lis2dh_OUT_X_L
                                                      gMockHID2X++;
                                                      blockArr[2+inner] = (gMockHID2X >> 8) & 0xFF; // Mid byte
                                                      blockArr[3+inner] = (gMockHID2X >> 0) & 0xFF; // Low byte
                                                      break;
                                              case 1: // mock LIS2DH lis2dh_OUT_Y_H,lis2dh_OUT_Y_L
                                                      gMockHID2Y++;
                                                      blockArr[2+inner] = (gMockHID2Y >> 8) & 0xFF; // Mid byte
                                                      blockArr[3+inner] = (gMockHID2Y >> 0) & 0xFF; // Low byte
                                                      break;
                                              case 2: // mock LIS2DH lis2dh_OUT_Z_H,lis2dh_OUT_Z_L
                                                      gMockHID2Z++;
                                                      blockArr[2+inner] = (gMockHID2Z >> 8) & 0xFF; // Mid byte
                                                      blockArr[3+inner] = (gMockHID2Z >> 0) & 0xFF; // Low byte
                                                      break;
                                      }
                                      gMockHIDFIFOChannel = gMockHIDFIFOChannel + 1;
                                      if (gMockHIDFIFOChannel >= 3) {
                                              gMockHIDFIFOChannel  = 0;
                                      }
                    }
                 }
                      //
                 // Send HID REPORT_ID(2) from blockArr[2..]
                 if (gLIS2DHdeviceAddress != 0) {
                    //
                    // VERIFY: OS24EVK-66 Send HID REPORT_ID(2)
                    // warning: if using ptrdelta to specify how many samples to read, do not read more than len(blockAr
             -r) bytes, otherwise memory access violation will occur
                    //i2c_read(gMAX30101deviceAddress & 0xFE, blockArr, ptrDelta * 6, 1);
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 18  

                    IO_BUFFER.Ptr[0] = HID_REPORT_ID_2;       // VERIFY: OS24EVK-66 need HID REPORT_ID(2)
                    IO_BUFFER.Ptr[1] = gLIS2DHnumIntServiced++; // VERIFY: OS24EVK-66 global counter for lis2dh numRepor
             -tsSent
                    IO_BUFFER.Ptr[2] = lis2dh_FIFO_SRC_REG_value; // VERIFY: OS24EVK-66 HID2 LIS2DH ptrDelta = 0x2F FIFO
             -_SRC_REG bits FFS4:0 
                    IO_BUFFER.Ptr[3] = '2'; // DIAGNOSTIC lis2dh_reserved_HID2_03 this is really HID#2        ovf; // Ov
             -erFlowCounter
                    for (inner=0; inner<(singleSample ? 6 : 60); inner++) {
                       IO_BUFFER.Ptr[4+inner] = blockArr[2+inner];
                    }
              // VERIFY: OS24EVK-66 USB_SUPPORT_SendPacketWaitEP1INready=1 SendPacketWaitEP1INready() as SendPacket() wi
             -th polling for INPRTY=0.
              #if USB_SUPPORT_SendPacketWaitEP1INready
                    SendPacketWaitEP1INready();
              #else // USB_SUPPORT_SendPacketWaitEP1INready
                    SendPacket();
              #endif // USB_SUPPORT_SendPacketWaitEP1INready
                    if (!singleReport)
                    {
                       if (ptrDelta == 0) {
                          ptrDelta = 32;
                       }
                       for (outer=0; outer<ptrDelta/10; outer++)      // integer division
                       {
                          bytesRemaining = ptrDelta*6-(outer+1)*60;   // each full loop sends 60 bytes: (outer+1)*60
                          for (inner=0; inner<(bytesRemaining <= 60 ? bytesRemaining : 60); inner++) {
                             IO_BUFFER.Ptr[4+inner] = blockArr[2+inner+(outer+1)*60];
                          }
              // VERIFY: OS24EVK-66 USB_SUPPORT_SendPacketWaitEP1INready=1 SendPacketWaitEP1INready() as SendPacket() wi
             -th polling for INPRTY=0.
              #if USB_SUPPORT_SendPacketWaitEP1INready
                          SendPacketWaitEP1INready();
              #else // USB_SUPPORT_SendPacketWaitEP1INready
                          SendPacket();
              #endif // USB_SUPPORT_SendPacketWaitEP1INready
                       }
                    }
                    //
              #if 1
                    // FAILED: (2015-04-13_v1.1) OS24EVK-66 ISR explicitly re-enable FIFO mode by lis2dh_configure_FIFO(
             -/* fifoModeFM10 1:FIFO mode */ 1, /* fifoTR */ 0, /* fifoWatermarkLevelFTH40 */ 0);
              #if 1 // OS24EVK-66 Firmware regresssion 2015-04-16_v1.1 (svn r=15232) vs 2015-04-15_v1.1 (svn r=15222): c
             -rashes GUI and Console program on connect (API ReadFile error).
                    lis2dh_RegRead(lis2dh_FIFO_SRC_REG, &lis2dh_FIFO_SRC_REG_value); //!< (read-only) WTM OVRN_FIFO EMPT
             -Y FSS4 FSS3 FSS2 FSS1 FSS0
                    if ((lis2dh_FIFO_SRC_REG_value & 0x40) != 0) {
                       // lis2dh_FIFO_SRC_REG bit OVRN_FIFO
                       lis2dh_configure_FIFO(/* fifoModeFM10 0:Bypass mode */ 0, /* fifoTR */ 0, /* fifoWatermarkLevelFT
             -H40 */ 0);
                       lis2dh_Read_XYZ(&gMockHID2X, &gMockHID2Y, &gMockHID2Z);
              # ifdef LIS2DH_DEFAULT_FIFOMODE
                       lis2dh_configure_FIFO(/* fifoModeFM10 1:FIFO mode */ LIS2DH_DEFAULT_FIFOMODE, /* fifoTR */ 0, LIS
             -2DH_DEFAULT_FIFOWATERMARKLEVEL);
              # else
                       lis2dh_configure_FIFO(/* fifoModeFM10 1:FIFO mode */ 1, /* fifoTR */ 0, /* fifoWatermarkLevelFTH4
             -0 */ 0);
              # endif
                    }
              #else // OS24EVK-66 Firmware regresssion 2015-04-16_v1.1 (svn r=15232) vs 2015-04-15_v1.1 (svn r=15222): c
             -rashes GUI and Console program on connect (API ReadFile error).
                    lis2dh_RegRead(lis2dh_FIFO_SRC_REG, &lis2dh_STATUS_REG2_value);
                    if ((lis2dh_STATUS_REG2_value & 0x40) != 0) {
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 19  

                       // lis2dh_FIFO_SRC_REG bit OVRN_FIFO
                       lis2dh_configure_FIFO(/* fifoModeFM10 0:Bypass mode */ 0, /* fifoTR */ 0, /* fifoWatermarkLevelFT
             -H40 */ 0);
                       lis2dh_Read_XYZ(&gMockHID2X, &gMockHID2Y, &gMockHID2Z);
              # ifdef LIS2DH_DEFAULT_FIFOMODE
                       lis2dh_configure_FIFO(/* fifoModeFM10 1:FIFO mode */ LIS2DH_DEFAULT_FIFOMODE, /* fifoTR */ 0, LIS
             -2DH_DEFAULT_FIFOWATERMARKLEVEL);
              # else
                       lis2dh_configure_FIFO(/* fifoModeFM10 1:FIFO mode */ 1, /* fifoTR */ 0, /* fifoWatermarkLevelFTH4
             -0 */ 0);
              # endif
                    }
              #endif // OS24EVK-66 Firmware regresssion 2015-04-16_v1.1 (svn r=15232) vs 2015-04-15_v1.1 (svn r=15222): 
             -crashes GUI and Console program on connect (API ReadFile error).
              #endif
                    //
                 }
              #endif // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
              
              #endif // SUPPORT_LIS2DH
1034   1      } // readOS21() MAX30101 + Accelerometer FIFO readout interrupt 
1035          
1036          
1037          #if 1 // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
1038          //-----------------------------------------------------------------------------
1039          // Accelerometer interrupt,
1040          // trigger the same interrupt service routine
1041          // which reads the FIFO contents of LIS2DH.
1042          //
1043          // LIS2DH and MAX30101 internal clocks are not synchronous, so could have different FIFO levels.
1044          // Algorithms will low-pass filter etc. so don't care if output data rates are not exactly equal/synchrono
             -us.
1045          //
1046          // when gLIS2DHready
1047          void readLIS2DH()
1048          {
1049   1         // MAX30101: each sample is 3 bytes per channel
1050   1      #define MAX30101_Bytes_Per_Channel 3
1051   1              uint8_t inner;
1052   1              uint8_t outer;
1053   1              uint8_t ptrDelta;
1054   1         // VERIFY: OS24EVK-72 HID report 1 byte 3 = MAX30101_InterruptStatus1 (not MAX30101_OverFlowCounter)
1055   1              // uint8_t ovf;
1056   1         //~ uint8_t MAX30101_InterruptStatus1_value;
1057   1              uint8_t bytesRemaining;
1058   1              bit singleSample = 0;
1059   1              bit singleReport = 1;   // only return 60 bytes (10x 3-byte red and IR samples)
1060   1      //#if SUPPORT_MAX30101
1061   1      //   // VERIFY: OS24EVK-66 Replace int with uint8_t where applicable; conserve xdata space
1062   1      //   //~ uint8_t numBytesToRequestFromOpticalFIFO;
1063   1      //#else
1064   1      //   #define numBytesToRequestFromOpticalFIFO \
*** WARNING C329 IN LINE 1064 OF F3xx_USB0_ReportHandler.c: single-line comment contains line-continuation
1065   1      //   (singleSample                                            \
1066   1      //      ? (2 * MAX30101_Bytes_Per_Channel)                    \
1067   1      //      : (singleReport                                       \
1068   1      //         ? (2 * MAX30101_Bytes_Per_Channel * 10)            \
1069   1      //         : (ptrDelta * 2 * MAX30101_Bytes_Per_Channel)      \
1070   1      //         )                                                  \
1071   1      //      )
*** WARNING C329 IN LINE 1065 OF F3xx_USB0_ReportHandler.c: single-line comment contains line-continuation
*** WARNING C329 IN LINE 1066 OF F3xx_USB0_ReportHandler.c: single-line comment contains line-continuation
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 20  

*** WARNING C329 IN LINE 1067 OF F3xx_USB0_ReportHandler.c: single-line comment contains line-continuation
*** WARNING C329 IN LINE 1068 OF F3xx_USB0_ReportHandler.c: single-line comment contains line-continuation
*** WARNING C329 IN LINE 1069 OF F3xx_USB0_ReportHandler.c: single-line comment contains line-continuation
*** WARNING C329 IN LINE 1070 OF F3xx_USB0_ReportHandler.c: single-line comment contains line-continuation
1072   1      //
1073   1      //#endif // SUPPORT_MAX30101
1074   1      #if 1 // OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA
1075   1         // TODO1: OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA new data available when reading X,Y,Z
1076   1         uint8_t lis2dh_STATUS_REG2_value = 0; //!< (read-only) ZYXOR ZOR YOR XOR ZYXDA ZDA YDA XDA
1077   1      #if 1 // OS24EVK-66 Firmware regresssion 2015-04-16_v1.1 (svn r=15232) vs 2015-04-15_v1.1 (svn r=15222): c
             -rashes GUI and Console program on connect (API ReadFile error).
1078   1         // 2015-04-22 Yikes! This declaration alone is enough to break it.
1079   1         // Are we overloading some internal resource?
1080   1         // 2015-04-23 restored lis2dh_FIFO_SRC_REG_value, after compacting xdata by 6 bytes...
1081   1         //   2015-04-15_v1.1 (svn r=15222) Program Size: data=10.5 xdata=484 code=12705
1082   1         //   2015-04-16_v1.1 (svn r=15306) Program Size: data=10.5 xdata=478 code=12687
1083   1         // So that could mean the dragon still lurks, 5 bytes away...
1084   1         uint8_t lis2dh_FIFO_SRC_REG_value /* = 0 */ ; //!< (read-only) WTM OVRN_FIFO EMPTY FSS4 FSS3 FSS2 FSS1 
             -FSS0
1085   1      #endif // OS24EVK-66 Firmware regresssion 2015-04-16_v1.1 (svn r=15232) vs 2015-04-15_v1.1 (svn r=15222): 
             -crashes GUI and Console program on connect (API ReadFile error).
1086   1      #endif // OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA
1087   1         //
1088   1         // C not C++, so all local variables must be declared before any statements
1089   1         //
1090   1              if (singleSample) {
1091   2                      singleReport = 1;       //singleSample must be in a singleReport
1092   2              }
1093   1         // TODO: 2015-05-02 singleReport = 1 unless HR mode, in readLIS2DH()
1094   1         // TODO: 2015-05-02 cache value of MAX30101_ModeConfiguration in gMAX30101_ModeConfiguration_value
1095   1         if (gMAX30101_ModeConfiguration_value == 0x02) {
1096   2            // "ModeConfiguration",0x09,0x02,"r/w Mode Configuration (0x80=SHDN, 0x40=RESET, 0x07=MODE[2:0]): HR
             - mode"
1097   2            singleReport = 0;
1098   2         } else {
1099   2            // "ModeConfiguration",0x09,0x03,"r/w Mode Configuration (0x80=SHDN, 0x40=RESET, 0x07=MODE[2:0]): SP
             -O2 mode"
1100   2            // "ModeConfiguration",0x09,0x07,"r/w Mode Configuration (0x80=SHDN, 0x40=RESET, 0x07=MODE[2:0]): LE
             -D mode"
1101   2         }
1102   1              gLIS2DHready = 0;
1103   1              // clear interrupts (not checking brownout)
1104   1         
1105   1         //
1106   1         // VERIFY: OS24EVK-66 update *F3xx_USB0_ReportHandler.c* Interrupt Service Routine readOS21() to acquir
             -e accelerometer data and send a second HID report. 
1107   1         //
1108   1      #if SUPPORT_LIS2DH
1109   1         // read LIS2DH FIFO into blockArr[2..]
1110   1      #define LIS2DH_Bytes_Per_Channel 2
1111   1         if (gLIS2DHdeviceAddress != 0) {
1112   2            // TODO: OS24EVK-66 read LIS2DH FIFO into blockArr[2..]
1113   2      #if 1
1114   2            
1115   2            // TODO: OS24EVK-66 HID2 LIS2DH ptrDelta = 0x2F FIFO_SRC_REG bits FFS4:0
1116   2            lis2dh_RegRead(lis2dh_FIFO_SRC_REG, &lis2dh_FIFO_SRC_REG_value); //!< (read-only) WTM OVRN_FIFO EMPT
             -Y FSS4 FSS3 FSS2 FSS1 FSS0
1117   2            // ptrDelta = (lis2dh_FIFO_SRC_REG_value & 0x1F);
1118   2            ptrDelta = lis2dh_FIFO_SRC_REG_value; // diagnostic: give me all the 0x2F FIFO_SRC_REG bits 
1119   2            if ((lis2dh_FIFO_SRC_REG_value & 0x40) != 0) {
1120   3               // lis2dh_FIFO_SRC_REG bit OVRN_FIFO
1121   3      #if 1 // turn on the Red LED to indicate FIFO overflow happened
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 21  

1122   3               // VERIFY: OS24EVK-83 2015-05-01 turn on the Red LED to indicate FIFO overflow happened
1123   3               //   P2.2 = diagnostic LED driver DS1 (1=light,0=dark)
1124   3               Led1 = 1; // [RED]
1125   3               // Confirmed: in HR+XYZ mode, overflow does indeed happen.
1126   3      #endif // turn on the Red LED to indicate FIFO overflow happened
1127   3            }
1128   2            
1129   2      #if 0 // OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA      
                    // TODO1: OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA new data available when reading X,
             -Y,Z
                    do {
                       lis2dh_RegRead(lis2dh_STATUS_REG2, &lis2dh_STATUS_REG2_value);
                    } while ((lis2dh_STATUS_REG2_value & 0x08) != 0x08);
              #endif // OS24EVK-66 ISR Poll for 0x27 STATUS_REG2 bit 0x08 ZYXDA
1135   2            
1136   2            // TODO1: OS24EVK-66 Read LIS2DH XYZ FIFO using a single 60-byte I2C read operation in readOS21() //
             - read LIS2DH FIFO into blockArr[2..]
1137   2            #define numBytesToRequestFromLIS2DHFIFO 60
1138   2            //        This register streams out FIFO data, without auto-incrementing i2c register address
1139   2            blockArr[5] = lis2dh_OUT_X_L | 0x80; // start of FIFO register 
1140   2            // 2015-04-16 OS24EVK-66 OS24EVK-57 LIS2DH multiple-byte read requires (regAddress | 0x80)
1141   2            // LIS2DH data sheet pg 25 5.1.1 I2C operation (near last paragraph)
1142   2            // In order to read multiple bytes, it is necessary to assert the most significant bit of the subadd
             -ress
1143   2            // field. In other words, SUB(7) must be equal to 1 while SUB(6-0) represents the
1144   2            // address of first register to be read.
1145   2            //
1146   2            // Note this raw XYZ data is LITTLE-ENDIAN (least significant byte first)
1147   2            //
1148   2            //FIXME must use block read on FIFO as follows otherwise data is corrupted
1149   2            i2c_read(
1150   2               /* slaveAddress */ (gLIS2DHdeviceAddress & 0xFE), 
1151   2               /* uint8_t *pData */ blockArr, 
1152   2               /* lenData */ numBytesToRequestFromLIS2DHFIFO, 
1153   2               /* lenStartReg */ 1);
1154   2      #else
                    // mockup: read real X,Y,Z vector even if not from the FIFO
                    // VERIFY: OS24EVK-66 Restore the HID2 mock data diagnostic, verify no missing HID2 reports
                    lis2dh_Read_XYZ(&gMockHID2X, &gMockHID2Y, &gMockHID2Z);
                              for (inner=0; inner<(singleSample ? (6) : (singleReport ? (60) : (ptrDelta * 6))); inner += LIS2DH_Bytes
             -_Per_Channel) {
                                      switch(gMockHIDFIFOChannel) {
                                              case 0: // mock LIS2DH lis2dh_OUT_X_H,lis2dh_OUT_X_L
                                                      blockArr[2+inner] = (gMockHID2X >> 8) & 0xFF; // Mid byte
                                                      blockArr[3+inner] = (gMockHID2X >> 0) & 0xFF; // Low byte
                                                      break;
                                              case 1: // mock LIS2DH lis2dh_OUT_Y_H,lis2dh_OUT_Y_L
                                                      blockArr[2+inner] = (gMockHID2Y >> 8) & 0xFF; // Mid byte
                                                      blockArr[3+inner] = (gMockHID2Y >> 0) & 0xFF; // Low byte
                                                      break;
                                              case 2: // mock LIS2DH lis2dh_OUT_Z_H,lis2dh_OUT_Z_L
                                                      blockArr[2+inner] = (gMockHID2Z >> 8) & 0xFF; // Mid byte
                                                      blockArr[3+inner] = (gMockHID2Z >> 0) & 0xFF; // Low byte
                                                      break;
                                      }
                                      gMockHIDFIFOChannel = gMockHIDFIFOChannel + 1;
                                      if (gMockHIDFIFOChannel >= 3) {
                                              gMockHIDFIFOChannel  = 0;
                          lis2dh_Read_XYZ(&gMockHID2X, &gMockHID2Y, &gMockHID2Z);
                                      }
                    }
              #endif
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 22  

1180   2      
1181   2            // TODO1: Reset LIS2DH INT_ACC interrupt by reading INT1_SOURCE register
1182   2            // (2015-04-26) apparently reading INT1_SOURCE into lis2dh_FIFO_SRC_REG_value breaks the acceleromet
             -er data stream
1183   2            //~ lis2dh_RegRead(lis2dh_INT1_SOURCE, &lis2dh_FIFO_SRC_REG_value); //!< clear INT by reading INT1_S
             -RC register (read-only) 0 IA ZH ZL YH YL XH XL
1184   2      #if 0 // TODO1: (Firmware 2015-04-26) OS24EVK-66 OS24EVK-83 configure LIS2DH
                    // TODO1: (2015-04-27) apparently reading INT1_SOURCE disrupts the accelerometer OUT_Y data stream.
                    lis2dh_RegRead(lis2dh_INT1_SOURCE, 0 /* discard reg read value */ ); //!< clear INT by reading INT1_
             -SRC register (read-only) 0 IA ZH ZL YH YL XH XL
              #endif // TODO1: (Firmware 2015-04-26) OS24EVK-66 OS24EVK-83 configure LIS2DH
1188   2      
1189   2         }
1190   1              // firmware diagnostic to generate Mock HID REPORT_ID(2) data
1191   1              if (gMockHIDreport2 > 0) {
1192   2            // TODO1: OS24EVK-66 firmware diagnostic Mock HID REPORT_ID(2) 
1193   2                      // Add INT0Enable() firmware diagnostic to generate Mock HID reports
1194   2                      // Overwrite blockArr[2+inner...] with specified Mock data for testing
1195   2                      // INT0Enable(6) Mock HID REPORT_ID(2) x3 channels (X,Y,Z) 101, 201, 301, 102, 202, 302, 103, 203, 303, 
             -...
1196   2                      //
1197   2                      gMockHIDFIFOChannel  = 0;
1198   2                      //
1199   2                      // LIS2DH: each sample is 2 bytes per channel
1200   2                      for (inner=0; inner<(singleSample ? (6) : (singleReport ? (60) : (ptrDelta * 6))); inner += LIS2DH_Bytes
             -_Per_Channel) {
1201   3                              switch(gMockHIDFIFOChannel) {
1202   4                                      case 0: // mock LIS2DH lis2dh_OUT_X_H,lis2dh_OUT_X_L
1203   4                                              gMockHID2X++;
1204   4                                              blockArr[2+inner] = (gMockHID2X >> 8) & 0xFF; // Mid byte
1205   4                                              blockArr[3+inner] = (gMockHID2X >> 0) & 0xFF; // Low byte
1206   4                                              break;
1207   4                                      case 1: // mock LIS2DH lis2dh_OUT_Y_H,lis2dh_OUT_Y_L
1208   4                                              gMockHID2Y++;
1209   4                                              blockArr[2+inner] = (gMockHID2Y >> 8) & 0xFF; // Mid byte
1210   4                                              blockArr[3+inner] = (gMockHID2Y >> 0) & 0xFF; // Low byte
1211   4                                              break;
1212   4                                      case 2: // mock LIS2DH lis2dh_OUT_Z_H,lis2dh_OUT_Z_L
1213   4                                              gMockHID2Z++;
1214   4                                              blockArr[2+inner] = (gMockHID2Z >> 8) & 0xFF; // Mid byte
1215   4                                              blockArr[3+inner] = (gMockHID2Z >> 0) & 0xFF; // Low byte
1216   4                                              break;
1217   4                              }
1218   3                              gMockHIDFIFOChannel = gMockHIDFIFOChannel + 1;
1219   3                              if (gMockHIDFIFOChannel >= 3) {
1220   4                                      gMockHIDFIFOChannel  = 0;
1221   4                              }
1222   3            }
1223   2         }
1224   1              //
1225   1         // Send HID REPORT_ID(2) from blockArr[2..]
1226   1         if (gLIS2DHdeviceAddress != 0) {
1227   2            //
1228   2            // VERIFY: OS24EVK-66 Send HID REPORT_ID(2)
1229   2            // warning: if using ptrdelta to specify how many samples to read, do not read more than len(blockAr
             -r) bytes, otherwise memory access violation will occur
1230   2            //i2c_read(gMAX30101deviceAddress & 0xFE, blockArr, ptrDelta * 6, 1);
1231   2            IO_BUFFER.Ptr[0] = HID_REPORT_ID_2;       // VERIFY: OS24EVK-66 need HID REPORT_ID(2)
1232   2            IO_BUFFER.Ptr[1] = gLIS2DHnumIntServiced++; // VERIFY: OS24EVK-66 global counter for lis2dh numRepor
             -tsSent
1233   2            IO_BUFFER.Ptr[2] = lis2dh_FIFO_SRC_REG_value; // VERIFY: OS24EVK-66 HID2 LIS2DH ptrDelta = 0x2F FIFO
             -_SRC_REG bits FFS4:0 
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 23  

1234   2            IO_BUFFER.Ptr[3] = '2'; // DIAGNOSTIC lis2dh_reserved_HID2_03 this is really HID#2        ovf; // Ov
             -erFlowCounter
1235   2            for (inner=0; inner<(singleSample ? 6 : 60); inner++) {
1236   3               IO_BUFFER.Ptr[4+inner] = blockArr[2+inner];
1237   3            }
1238   2      // VERIFY: OS24EVK-66 USB_SUPPORT_SendPacketWaitEP1INready=1 SendPacketWaitEP1INready() as SendPacket() wi
             -th polling for INPRTY=0.
1239   2      #if USB_SUPPORT_SendPacketWaitEP1INready
1240   2            SendPacketWaitEP1INready();
1241   2      #else // USB_SUPPORT_SendPacketWaitEP1INready
                    SendPacket();
              #endif // USB_SUPPORT_SendPacketWaitEP1INready
1244   2            if (!singleReport)
1245   2            {
1246   3               if (ptrDelta == 0) {
1247   4                  ptrDelta = 32;
1248   4               }
1249   3               for (outer=0; outer<ptrDelta/10; outer++)      // integer division
1250   3               {
1251   4                  bytesRemaining = ptrDelta*6-(outer+1)*60;   // each full loop sends 60 bytes: (outer+1)*60
1252   4                  for (inner=0; inner<(bytesRemaining <= 60 ? bytesRemaining : 60); inner++) {
1253   5                     IO_BUFFER.Ptr[4+inner] = blockArr[2+inner+(outer+1)*60];
1254   5                  }
1255   4      // VERIFY: OS24EVK-66 USB_SUPPORT_SendPacketWaitEP1INready=1 SendPacketWaitEP1INready() as SendPacket() wi
             -th polling for INPRTY=0.
1256   4      #if USB_SUPPORT_SendPacketWaitEP1INready
1257   4                  SendPacketWaitEP1INready();
1258   4      #else // USB_SUPPORT_SendPacketWaitEP1INready
                          SendPacket();
              #endif // USB_SUPPORT_SendPacketWaitEP1INready
1261   4               }
1262   3            }
1263   2            //
1264   2      #if 1
1265   2            // FAILED: (2015-04-13_v1.1) OS24EVK-66 ISR explicitly re-enable FIFO mode by lis2dh_configure_FIFO(
             -/* fifoModeFM10 1:FIFO mode */ 1, /* fifoTR */ 0, /* fifoWatermarkLevelFTH40 */ 0);
1266   2      #if 1 // OS24EVK-66 Firmware regresssion 2015-04-16_v1.1 (svn r=15232) vs 2015-04-15_v1.1 (svn r=15222): c
             -rashes GUI and Console program on connect (API ReadFile error).
1267   2            lis2dh_RegRead(lis2dh_FIFO_SRC_REG, &lis2dh_FIFO_SRC_REG_value); //!< (read-only) WTM OVRN_FIFO EMPT
             -Y FSS4 FSS3 FSS2 FSS1 FSS0
1268   2            if ((lis2dh_FIFO_SRC_REG_value & 0x40) != 0) {
1269   3               // lis2dh_FIFO_SRC_REG bit OVRN_FIFO
1270   3               lis2dh_configure_FIFO(/* fifoModeFM10 0:Bypass mode */ 0, /* fifoTR */ 0, /* fifoWatermarkLevelFT
             -H40 */ 0);
1271   3               lis2dh_Read_XYZ(&gMockHID2X, &gMockHID2Y, &gMockHID2Z);
*** WARNING C182 IN LINE 1271 OF F3xx_USB0_ReportHandler.c: pointer to different objects
*** WARNING C182 IN LINE 1271 OF F3xx_USB0_ReportHandler.c: pointer to different objects
*** WARNING C182 IN LINE 1271 OF F3xx_USB0_ReportHandler.c: pointer to different objects
1272   3      # ifdef LIS2DH_DEFAULT_FIFOMODE
1273   3               lis2dh_configure_FIFO(/* fifoModeFM10 1:FIFO mode */ LIS2DH_DEFAULT_FIFOMODE, /* fifoTR */ 0, LIS
             -2DH_DEFAULT_FIFOWATERMARKLEVEL);
1274   3      # else
                       lis2dh_configure_FIFO(/* fifoModeFM10 1:FIFO mode */ 1, /* fifoTR */ 0, /* fifoWatermarkLevelFTH4
             -0 */ 0);
              # endif
1277   3      #if 1 // turn on the Red LED to indicate FIFO overflow happened
1278   3               // VERIFY: OS24EVK-83 2015-05-01 turn on the Red LED to indicate FIFO overflow happened
1279   3               //   P2.2 = diagnostic LED driver DS1 (1=light,0=dark)
1280   3               Led1 = 1; // [RED]
1281   3               // Confirmed: in HR+XYZ mode, overflow does indeed happen.
1282   3      #endif // turn on the Red LED to indicate FIFO overflow happened
1283   3            }
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 24  

1284   2      #else // OS24EVK-66 Firmware regresssion 2015-04-16_v1.1 (svn r=15232) vs 2015-04-15_v1.1 (svn r=15222): c
             -rashes GUI and Console program on connect (API ReadFile error).
                    lis2dh_RegRead(lis2dh_FIFO_SRC_REG, &lis2dh_STATUS_REG2_value);
                    if ((lis2dh_STATUS_REG2_value & 0x40) != 0) {
                       // lis2dh_FIFO_SRC_REG bit OVRN_FIFO
                       lis2dh_configure_FIFO(/* fifoModeFM10 0:Bypass mode */ 0, /* fifoTR */ 0, /* fifoWatermarkLevelFT
             -H40 */ 0);
                       lis2dh_Read_XYZ(&gMockHID2X, &gMockHID2Y, &gMockHID2Z);
              # ifdef LIS2DH_DEFAULT_FIFOMODE
                       lis2dh_configure_FIFO(/* fifoModeFM10 1:FIFO mode */ LIS2DH_DEFAULT_FIFOMODE, /* fifoTR */ 0, LIS
             -2DH_DEFAULT_FIFOWATERMARKLEVEL);
              # else
                       lis2dh_configure_FIFO(/* fifoModeFM10 1:FIFO mode */ 1, /* fifoTR */ 0, /* fifoWatermarkLevelFTH4
             -0 */ 0);
              # endif
                    }
              #endif // OS24EVK-66 Firmware regresssion 2015-04-16_v1.1 (svn r=15232) vs 2015-04-15_v1.1 (svn r=15222): 
             -crashes GUI and Console program on connect (API ReadFile error).
1297   2      #endif
1298   2            //
1299   2         }
1300   1      }
1301          #endif // TODO1: OS24EVK-83 (firmware 2015-04-29) separate trigger for LIS2DH-only interrupt service
1302          
1303          // OS24EVK-66 SMBusReadByte protocol I2C 8-bit register read
1304          //
1305          // @param[in] deviceAddress = I2C device address (slave address on I2C bus), 8-bits, LEFT-justified.
1306          // @param[in] regAddress = 8-bit register address
1307          // @param[out] pRegValue = optional buffer to get the received data
1308          // @post global blockarr is used
1309          // @pre global gOffset = 0 or 1 depending on whether EXPLICIT_REPORT_ID
1310          //
1311          // @return -1 on NACK, or 1 on success
1312          //
1313          #if SUPPORT_i2c_smbus_read_byte_data
1314          int8_t i2c_smbus_read_byte_data(uint8_t deviceAddress, uint8_t regAddress, uint8_t *pRegValue)
1315          {
1316   1         uint8_t regValue;
1317   1         uint8_t status;
1318   1         //
1319   1         // C not C++, so all local variables must be declared before any statements
1320   1         //
1321   1         blockArr[4+gOffset] = regAddress;
1322   1         //  SMBusReadByte is i2c_read(deviceAddress, blockArray, 2, 1)
1323   1      #if 1
1324   1         // OS24EVK-66 Firmware v1.1 2015-03-29 scope check; i2c_smbus_read_byte_data i2c_read with numDataBytes
             - = 1 instead of 2.
1325   1         // VERIFY: OS24EVK-66 i2c_smbus_read_byte_data i2c_read with numDataBytes = 1 instead of 2, avoid unnec
             -essary extra byte readout?
1326   1         // Looks like this doesn't work -- firmware doesn't find the devices?
1327   1         // Yet HID I2C commands do access the devices ok.
1328   1         // But then streaming data doesn't seem to generate HID reports,
1329   1         // despite being able to turn on the optical device LEDs.
1330   1         i2c_read(/* deviceAddress = I2C_ADDRESS */ (deviceAddress & 0xFE), 
1331   1                      blockArr, 
1332   1                      /* lenData:numDataBytes = 2 */    1, // TODO1: OS24EVK-66 i2c_smbus_read_byte_data i2c_read with numData
             -Bytes = 1 instead of 2, avoid unnecessary extra byte readout?
1333   1                      /* lenStartReg:numRegBytes = 1 */ 1); 
1334   1         // after first call: blockArr[] = { 0x01, 0x00 status, 0x15 regValue, 0x01, 0x20, 0xFF, 0x02, 0x20, ...
             - }
1335   1         status = blockArr[0+gOffset];
1336   1         regValue = blockArr[1+gOffset]; // readData[i] = IOBuf[i + 1];
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 25  

1337   1      #else
                 // Initial address search works, but I don't understand why lenData:numDataBytes = 2 instead of 1.
                 i2c_read(/* deviceAddress = I2C_ADDRESS */ (deviceAddress & 0xFE), 
                              blockArr, 
                              /* lenData:numDataBytes = 2 */    2, 
                              /* lenStartReg:numRegBytes = 1 */ 1); 
                 // after first call: blockArr[] = { 0x01, 0x00 status, 0x15 regValue, 0x15 regValue, 0x20, 0xFF, 0x02, 
             -0x20, ... }
                 status = blockArr[0+gOffset];
                 regValue = blockArr[2+gOffset]; // readData[i] = IOBuf[i + 2];
                 // looks like thie 2+gOffset isn't really right for Byte Read.
              #endif
1348   1         //   blockArr[2+0] = value read from Device Register
1349   1         //
1350   1         if (status != 0) {
1351   2            return -1; // NACK
1352   2         }
1353   1         //
1354   1         if (pRegValue != 0) {
1355   2            *(pRegValue) = regValue;
1356   2         }
1357   1         return 1; // ACK
1358   1      }
1359          #endif // SUPPORT_i2c_smbus_read_byte_data
1360          
1361          #if SUPPORT_i2c_smbus_read_bytes_data
              // OS24EVK-66 SMBusReadByte protocol I2C 8-bit register read, multiple consecutive bytes
              //
              // @param[in] deviceAddress = I2C device address (slave address on I2C bus), 8-bits, LEFT-justified.
              // @param[in] regAddress = 8-bit register address of first byte
              // @param[in] count = number of consecutive register addresses to read
              // @param[out] pRegValue = optional buffer to get the received data
              // @post global blockarr is used
              // @pre global gOffset = 0 or 1 depending on whether EXPLICIT_REPORT_ID
              //
              // @return -1 on NACK, or 1 on success
              //
              int8_t i2c_smbus_read_bytes_data(uint8_t deviceAddress, uint8_t regAddress, uint8_t count, uint8_t *pRegVa
             -lue)
              {
                 uint8_t regValue;
                 uint8_t status;
                 //
                 // C not C++, so all local variables must be declared before any statements
                 //
                 blockArr[4+gOffset] = regAddress;
                 //  SMBusReadByte is i2c_read(deviceAddress, blockArray, 2, 1)
                 i2c_read(/* deviceAddress = I2C_ADDRESS */ (deviceAddress & 0xFE), 
                              blockArr, 
                              /* lenData:numDataBytes = 2 */    count,
                              /* lenStartReg:numRegBytes = 1 */ 1); 
                 status = blockArr[0+gOffset];
                 regValue = blockArr[2+gOffset]; // readData[i] = IOBuf[i + 2];
                 //   blockArr[2+0] = value read from Device Register
                 //
                 if (status != 0) {
                    return -1; // NACK
                 }
                 //
                 if (pRegValue != 0) {
                    while (count > 0) {
                       *(pRegValue+count) = blockArr[2+gOffset+count];
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 26  

                    }
                 }
                 return 1; // ACK
              }
              #endif // SUPPORT_i2c_smbus_read_bytes_data
1402          
1403          // OS24EVK-66 SMBusWriteByte protocol I2C 8-bit register read
1404          //
1405          // @param[in] deviceAddress = I2C device address (slave address on I2C bus), 8-bits, LEFT-justified.
1406          // @param[in] regAddress = 8-bit register address
1407          // @param[in] regValue = 8-bit register value
1408          // @post global blockarr is used
1409          // @pre global gOffset = 0 or 1 depending on whether EXPLICIT_REPORT_ID
1410          //
1411          // @return -1 on NACK, or 1 on success
1412          //
1413          #if SUPPORT_i2c_smbus_read_byte_data
1414          int8_t i2c_smbus_write_byte_data(uint8_t deviceAddress, uint8_t regAddress, uint8_t regValue)
1415          {
1416   1         uint8_t status;
1417   1         //
1418   1         // C not C++, so all local variables must be declared before any statements
1419   1         //
1420   1         blockArr[4+gOffset] = regAddress;
1421   1         blockArr[5+gOffset] = regValue;
1422   1         i2c_write(/* deviceAddress = I2C_ADDRESS */ (deviceAddress & 0xFE), 
1423   1                      blockArr, 
1424   1                      /* lenData:numDataBytes = 1 */    1, 
1425   1                      /* lenStartReg:numRegBytes = 1 */ 1); 
1426   1            // note that start register address & data start at IO_BUFFER.Ptr[4]
1427   1         status = blockArr[0+gOffset];
1428   1         //
1429   1         if (status != 0) {
1430   2            return -1; // NACK
1431   2         }
1432   1         return 1; // ACK
1433   1      }
1434          #endif // SUPPORT_i2c_smbus_read_byte_data
1435          
1436          
1437          #if SUPPORT_LED1_LED2_DIAGNOSTIC
1438          // OS24EVK-66 flashing diagnostic LEDs
1439          void flash_Led1L_Led2L_100ms()
1440          {
1441   1         Led1 = 0;
1442   1         Led2 = 0;
1443   1         Timer0_Init(TIMER0_INIT_DELAY_HALFMS);
1444   1         T0_Wait(200);
1445   1      }
1446          #endif // SUPPORT_LED1_LED2_DIAGNOSTIC
1447          
1448          #if SUPPORT_LED1_LED2_DIAGNOSTIC
1449          // OS24EVK-66 flashing diagnostic LEDs
1450          void flash_Led1L_Led2H_100ms()
1451          {
1452   1         Led1 = 0;
1453   1         Led2 = 1;
1454   1         Timer0_Init(TIMER0_INIT_DELAY_HALFMS);
1455   1         T0_Wait(200);
1456   1      }
1457          #endif // SUPPORT_LED1_LED2_DIAGNOSTIC
1458          
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 27  

1459          #if SUPPORT_LED1_LED2_DIAGNOSTIC
1460          // OS24EVK-66 flashing diagnostic LEDs
1461          void flash_Led1H_Led2L_100ms()
1462          {
1463   1         Led1 = 1;
1464   1         Led2 = 0;
1465   1         Timer0_Init(TIMER0_INIT_DELAY_HALFMS);
1466   1         T0_Wait(200);
1467   1      }
1468          #endif // SUPPORT_LED1_LED2_DIAGNOSTIC
1469          
1470          #if SUPPORT_LED1_LED2_DIAGNOSTIC
1471          // OS24EVK-66 flashing diagnostic LEDs
1472          void flash_Led1H_Led2H_100ms()
1473          {
1474   1         Led1 = 1;
1475   1         Led2 = 1;
1476   1         Timer0_Init(TIMER0_INIT_DELAY_HALFMS);
1477   1         T0_Wait(200);
1478   1      }
1479          #endif // SUPPORT_LED1_LED2_DIAGNOSTIC
1480          
1481          #if SUPPORT_LED1_LED2_DIAGNOSTIC
1482          void flash_Led1Led2_East()
1483          {
1484   1         flash_Led1H_Led2H_100ms(); // [RED] [GREEN]
1485   1         flash_Led1L_Led2H_100ms(); // [   ] [GREEN]
1486   1         flash_Led1L_Led2L_100ms(); // [   ] [     ]
1487   1         flash_Led1H_Led2L_100ms(); // [RED] [     ]
1488   1         flash_Led1H_Led2H_100ms(); // [RED] [GREEN]
1489   1      }
1490          #endif // SUPPORT_LED1_LED2_DIAGNOSTIC
1491          
1492          #if SUPPORT_LED1_LED2_DIAGNOSTIC
1493          void flash_Led1Led2_Blink()
1494          {
1495   1         flash_Led1H_Led2H_100ms(); // [RED] [GREEN]
1496   1         flash_Led1L_Led2L_100ms(); // [   ] [     ]
1497   1         flash_Led1H_Led2H_100ms(); // [RED] [GREEN]
1498   1      }
1499          #endif // SUPPORT_LED1_LED2_DIAGNOSTIC
1500          
1501          #if SUPPORT_P20BTN_DIAGNOSTIC
              //   P2.0 = diagnostic pushbutton on C8051F321 daughtercard TOOLSTICK321DC (0=pressed; 1=not pressed)
              int16_t P20Btn_Pressed()
              {
                 return !P20Btn;
              }
              #endif // SUPPORT_P20BTN_DIAGNOSTIC
1508          
1509          
*** WARNING C316 IN LINE 1509 OF F3xx_USB0_ReportHandler.c: unterminated conditionals
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 28  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _OUT_REPORT_HANDLER (BEGIN)
                                           ; SOURCE LINE # 148
0000 900000      R     MOV     DPTR,#internalCall
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 149
                                           ; SOURCE LINE # 156
0008 900000      R     MOV     DPTR,#gOffset
000B 7401              MOV     A,#01H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
000E 900000      R     MOV     DPTR,#IO_BUFFER+01H
0011 E0                MOVX    A,@DPTR
0012 FB                MOV     R3,A
0013 A3                INC     DPTR
0014 E0                MOVX    A,@DPTR
0015 FA                MOV     R2,A
0016 A3                INC     DPTR
0017 E0                MOVX    A,@DPTR
0018 F9                MOV     R1,A
0019 900000      R     MOV     DPTR,#gOffset
001C E0                MOVX    A,@DPTR
001D F582              MOV     DPL,A
001F 758300            MOV     DPH,#00H
0022 120000      E     LCALL   ?C?CLDOPTR
0025 24E9              ADD     A,#0E9H
0027 7003              JNZ     $ + 5H
0029 020000      R     LJMP    ?C0045
002C 2417              ADD     A,#017H
002E B40A00            CJNE    A,#0AH,?C0147
0031         ?C0147:
0031 4003              JC      $ + 5H
0033 020000      R     LJMP    ?C0057
0036 900000      R     MOV     DPTR,#?C0148
0039 F8                MOV     R0,A
003A 28                ADD     A,R0
003B 28                ADD     A,R0
003C 73                JMP     @A+DPTR
003D         ?C0148:
003D 020000      R     LJMP    ?C0002
0040 020000      R     LJMP    ?C0003
0043 020000      R     LJMP    ?C0007
0046 020000      R     LJMP    ?C0013
0049 020000      R     LJMP    ?C0018
004C 020000      R     LJMP    ?C0025
004F 020000      R     LJMP    ?C0029
0052 020000      R     LJMP    ?C0034
0055 020000      R     LJMP    ?C0038
0058 020000      R     LJMP    ?C0042
                                           ; SOURCE LINE # 161
                                           ; SOURCE LINE # 162
005B         ?C0002:
                                           ; SOURCE LINE # 164
005B 900000      R     MOV     DPTR,#IO_BUFFER+01H
005E E0                MOVX    A,@DPTR
005F FB                MOV     R3,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 29  

0060 A3                INC     DPTR
0061 E0                MOVX    A,@DPTR
0062 FA                MOV     R2,A
0063 A3                INC     DPTR
0064 E0                MOVX    A,@DPTR
0065 F9                MOV     R1,A
0066 7401              MOV     A,#01H
0068 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 165
006B 900000      R     MOV     DPTR,#IO_BUFFER+01H
006E E0                MOVX    A,@DPTR
006F FB                MOV     R3,A
0070 A3                INC     DPTR
0071 E0                MOVX    A,@DPTR
0072 FA                MOV     R2,A
0073 A3                INC     DPTR
0074 E0                MOVX    A,@DPTR
0075 F9                MOV     R1,A
0076 900000      R     MOV     DPTR,#gOffset
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B F582              MOV     DPL,A
007D 758300            MOV     DPH,#00H
0080 E4                CLR     A
0081 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 166
0084 900000      E     MOV     DPTR,#versionInfo
0087 E0                MOVX    A,@DPTR
0088 FE                MOV     R6,A
0089 EF                MOV     A,R7
008A F582              MOV     DPL,A
008C 758300            MOV     DPH,#00H
008F A3                INC     DPTR
0090 EE                MOV     A,R6
0091 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 167
0094 900000      E     MOV     DPTR,#versionInfo+01H
0097 E0                MOVX    A,@DPTR
0098 FF                MOV     R7,A
0099 900000      R     MOV     DPTR,#gOffset
009C E0                MOVX    A,@DPTR
009D F582              MOV     DPL,A
009F 758300            MOV     DPH,#00H
00A2 A3                INC     DPTR
00A3 A3                INC     DPTR
00A4 EF                MOV     A,R7
00A5 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 168
00A8 900000      E     MOV     DPTR,#versionInfo+02H
00AB E0                MOVX    A,@DPTR
00AC FF                MOV     R7,A
00AD 900000      R     MOV     DPTR,#gOffset
00B0 E0                MOVX    A,@DPTR
00B1 F582              MOV     DPL,A
00B3 758300            MOV     DPH,#00H
00B6 A3                INC     DPTR
00B7 A3                INC     DPTR
00B8 A3                INC     DPTR
00B9 EF                MOV     A,R7
00BA 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 169
00BD 900000      E     MOV     DPTR,#versionInfo+02H
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 30  

00C0 A3                INC     DPTR
00C1 E0                MOVX    A,@DPTR
00C2 FF                MOV     R7,A
00C3 900000      R     MOV     DPTR,#gOffset
00C6 E0                MOVX    A,@DPTR
00C7 FE                MOV     R6,A
00C8 2404              ADD     A,#04H
00CA F582              MOV     DPL,A
00CC E4                CLR     A
00CD 33                RLC     A
00CE F583              MOV     DPH,A
00D0 EF                MOV     A,R7
00D1 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 170
00D4 900000      E     MOV     DPTR,#versionInfo+04H
00D7 E0                MOVX    A,@DPTR
00D8 FF                MOV     R7,A
00D9 EE                MOV     A,R6
00DA 2405              ADD     A,#05H
00DC F582              MOV     DPL,A
00DE E4                CLR     A
00DF 33                RLC     A
00E0 F583              MOV     DPH,A
00E2 EF                MOV     A,R7
00E3 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 171
00E6 900000      E     MOV     DPTR,#versionInfo+05H
00E9 E0                MOVX    A,@DPTR
00EA FF                MOV     R7,A
00EB EE                MOV     A,R6
00EC 2406              ADD     A,#06H
00EE F582              MOV     DPL,A
00F0 E4                CLR     A
00F1 33                RLC     A
00F2 F583              MOV     DPH,A
                                           ; SOURCE LINE # 172
                                           ; SOURCE LINE # 173
00F4 020000      R     LJMP    ?C0158
                                           ; SOURCE LINE # 174
00F7         ?C0003:
                                           ; SOURCE LINE # 175
00F7 900000      R     MOV     DPTR,#gOffset
00FA E0                MOVX    A,@DPTR
00FB FF                MOV     R7,A
00FC 7E00              MOV     R6,#00H
00FE 2401              ADD     A,#01H
0100 FD                MOV     R5,A
0101 EE                MOV     A,R6
0102 33                RLC     A
0103 FC                MOV     R4,A
0104 900000      R     MOV     DPTR,#IO_BUFFER+01H
0107 E0                MOVX    A,@DPTR
0108 FB                MOV     R3,A
0109 A3                INC     DPTR
010A E0                MOVX    A,@DPTR
010B FA                MOV     R2,A
010C A3                INC     DPTR
010D E0                MOVX    A,@DPTR
010E F9                MOV     R1,A
010F 8D82              MOV     DPL,R5
0111 8C83              MOV     DPH,R4
0113 120000      E     LCALL   ?C?CLDOPTR
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 31  

0116 14                DEC     A
0117 601D              JZ      ?C0006
0119 04                INC     A
011A 6003              JZ      $ + 5H
011C 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 176
                                           ; SOURCE LINE # 177
011F         ?C0005:
                                           ; SOURCE LINE # 178
011F 8F82              MOV     DPL,R7
0121 8E83              MOV     DPH,R6
0123 A3                INC     DPTR
0124 A3                INC     DPTR
0125 120000      E     LCALL   ?C?CLDOPTR
0128 FF                MOV     R7,A
0129 13                RRC     A
012A 92A1              MOV     Led2,C
                                           ; SOURCE LINE # 179
012C EF                MOV     A,R7
012D 5402              ANL     A,#02H
012F C3                CLR     C
0130 13                RRC     A
0131 24FF              ADD     A,#0FFH
0133 92A2              MOV     Led1,C
                                           ; SOURCE LINE # 180
0135 22                RET     
                                           ; SOURCE LINE # 181
0136         ?C0006:
                                           ; SOURCE LINE # 182
0136 E4                CLR     A
0137 FF                MOV     R7,A
0138 120000      E     LCALL   _Timer0_Init
                                           ; SOURCE LINE # 183
013B 900000      R     MOV     DPTR,#gOffset
013E E0                MOVX    A,@DPTR
013F FD                MOV     R5,A
0140 7C00              MOV     R4,#00H
0142 2402              ADD     A,#02H
0144 FF                MOV     R7,A
0145 EC                MOV     A,R4
0146 33                RLC     A
0147 FE                MOV     R6,A
0148 900000      R     MOV     DPTR,#IO_BUFFER+01H
014B E0                MOVX    A,@DPTR
014C FB                MOV     R3,A
014D A3                INC     DPTR
014E E0                MOVX    A,@DPTR
014F FA                MOV     R2,A
0150 A3                INC     DPTR
0151 E0                MOVX    A,@DPTR
0152 F9                MOV     R1,A
0153 8F82              MOV     DPL,R7
0155 8E83              MOV     DPH,R6
0157 120000      E     LCALL   ?C?CLDOPTR
015A FE                MOV     R6,A
015B 8D82              MOV     DPL,R5
015D 8C83              MOV     DPH,R4
015F A3                INC     DPTR
0160 A3                INC     DPTR
0161 A3                INC     DPTR
0162 120000      E     LCALL   ?C?CLDOPTR
0165 2400              ADD     A,#00H
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 32  

0167 FF                MOV     R7,A
0168 EC                MOV     A,R4
0169 3E                ADDC    A,R6
016A FE                MOV     R6,A
016B 120000      E     LCALL   _T0_Wait
                                           ; SOURCE LINE # 184
016E 900000      R     MOV     DPTR,#IO_BUFFER+01H
0171 E0                MOVX    A,@DPTR
0172 FB                MOV     R3,A
0173 A3                INC     DPTR
0174 E0                MOVX    A,@DPTR
0175 FA                MOV     R2,A
0176 A3                INC     DPTR
0177 E0                MOVX    A,@DPTR
0178 F9                MOV     R1,A
0179 7401              MOV     A,#01H
017B 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 185
017E 900000      R     MOV     DPTR,#IO_BUFFER+01H
0181 E0                MOVX    A,@DPTR
0182 FB                MOV     R3,A
0183 A3                INC     DPTR
0184 E0                MOVX    A,@DPTR
0185 FA                MOV     R2,A
0186 A3                INC     DPTR
0187 E0                MOVX    A,@DPTR
0188 F9                MOV     R1,A
0189 900000      R     MOV     DPTR,#gOffset
018C E0                MOVX    A,@DPTR
018D FF                MOV     R7,A
018E F582              MOV     DPL,A
0190 758300            MOV     DPH,#00H
0193 E4                CLR     A
0194 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 187
0197 8F82              MOV     DPL,R7
0199 758300            MOV     DPH,#00H
019C A3                INC     DPTR
019D E580              MOV     A,P0
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 189
019F 020000      R     LJMP    ?C0160
                                           ; SOURCE LINE # 190
                                           ; SOURCE LINE # 191
                                           ; SOURCE LINE # 192
01A2         ?C0007:
                                           ; SOURCE LINE # 193
01A2 900000      R     MOV     DPTR,#gOffset
01A5 E0                MOVX    A,@DPTR
01A6 FF                MOV     R7,A
01A7 7E00              MOV     R6,#00H
01A9 2401              ADD     A,#01H
01AB FD                MOV     R5,A
01AC EE                MOV     A,R6
01AD 33                RLC     A
01AE FC                MOV     R4,A
01AF 900000      R     MOV     DPTR,#IO_BUFFER+01H
01B2 E0                MOVX    A,@DPTR
01B3 FB                MOV     R3,A
01B4 A3                INC     DPTR
01B5 E0                MOVX    A,@DPTR
01B6 FA                MOV     R2,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 33  

01B7 A3                INC     DPTR
01B8 E0                MOVX    A,@DPTR
01B9 F9                MOV     R1,A
01BA 8D82              MOV     DPL,R5
01BC 8C83              MOV     DPH,R4
01BE 120000      E     LCALL   ?C?CLDOPTR
01C1 14                DEC     A
01C2 6037              JZ      ?C0012
01C4 04                INC     A
01C5 6003              JZ      $ + 5H
01C7 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 194
                                           ; SOURCE LINE # 195
01CA         ?C0009:
                                           ; SOURCE LINE # 196
01CA 8F82              MOV     DPL,R7
01CC 8E83              MOV     DPH,R6
01CE A3                INC     DPTR
01CF A3                INC     DPTR
01D0 120000      E     LCALL   ?C?CLDOPTR
01D3 F5A5              MOV     P1MDOUT,A
                                           ; SOURCE LINE # 197
01D5 8F82              MOV     DPL,R7
01D7 8E83              MOV     DPH,R6
01D9 A3                INC     DPTR
01DA A3                INC     DPTR
01DB A3                INC     DPTR
01DC 120000      E     LCALL   ?C?CLDOPTR
01DF F5A6              MOV     P2MDOUT,A
                                           ; SOURCE LINE # 198
01E1 900000      R     MOV     DPTR,#gOffset
01E4 E0                MOVX    A,@DPTR
01E5 2404              ADD     A,#04H
01E7 F582              MOV     DPL,A
01E9 E4                CLR     A
01EA 33                RLC     A
01EB F583              MOV     DPH,A
01ED 120000      E     LCALL   ?C?CLDOPTR
01F0 30E004            JNB     ACC.0,?C0010
01F3 43E280            ORL     XBR1,#080H
01F6 22                RET     
01F7         ?C0010:
01F7 53E27F            ANL     XBR1,#07FH
                                           ; SOURCE LINE # 199
01FA 22                RET     
                                           ; SOURCE LINE # 200
01FB         ?C0012:
                                           ; SOURCE LINE # 201
01FB 900000      R     MOV     DPTR,#IO_BUFFER+01H
01FE E0                MOVX    A,@DPTR
01FF FB                MOV     R3,A
0200 A3                INC     DPTR
0201 E0                MOVX    A,@DPTR
0202 FA                MOV     R2,A
0203 A3                INC     DPTR
0204 E0                MOVX    A,@DPTR
0205 F9                MOV     R1,A
0206 7401              MOV     A,#01H
0208 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 202
020B 900000      R     MOV     DPTR,#IO_BUFFER+01H
020E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 34  

020F FB                MOV     R3,A
0210 A3                INC     DPTR
0211 E0                MOVX    A,@DPTR
0212 FA                MOV     R2,A
0213 A3                INC     DPTR
0214 E0                MOVX    A,@DPTR
0215 F9                MOV     R1,A
0216 900000      R     MOV     DPTR,#gOffset
0219 E0                MOVX    A,@DPTR
021A FF                MOV     R7,A
021B F582              MOV     DPL,A
021D 758300            MOV     DPH,#00H
0220 E4                CLR     A
0221 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 203
0224 7E00              MOV     R6,#00H
0226 8F82              MOV     DPL,R7
0228 8E83              MOV     DPH,R6
022A A3                INC     DPTR
022B E5A5              MOV     A,P1MDOUT
022D 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 204
0230 8F82              MOV     DPL,R7
0232 8E83              MOV     DPH,R6
0234 A3                INC     DPTR
0235 A3                INC     DPTR
0236 E5A6              MOV     A,P2MDOUT
0238 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 205
023B E5E2              MOV     A,XBR1
023D 5480              ANL     A,#080H
023F C4                SWAP    A
0240 13                RRC     A
0241 13                RRC     A
0242 13                RRC     A
0243 5401              ANL     A,#01H
0245 FF                MOV     R7,A
0246 900000      R     MOV     DPTR,#gOffset
0249 E0                MOVX    A,@DPTR
024A F582              MOV     DPL,A
024C 758300            MOV     DPH,#00H
024F A3                INC     DPTR
0250 A3                INC     DPTR
0251 A3                INC     DPTR
0252 EF                MOV     A,R7
0253         ?C0159:
                                           ; SOURCE LINE # 206
                                           ; SOURCE LINE # 207
0253 020000      R     LJMP    ?C0160
                                           ; SOURCE LINE # 208
                                           ; SOURCE LINE # 209
                                           ; SOURCE LINE # 210
0256         ?C0013:
                                           ; SOURCE LINE # 211
0256 900000      R     MOV     DPTR,#gOffset
0259 E0                MOVX    A,@DPTR
025A FF                MOV     R7,A
025B 7E00              MOV     R6,#00H
025D 2401              ADD     A,#01H
025F FD                MOV     R5,A
0260 EE                MOV     A,R6
0261 33                RLC     A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 35  

0262 FC                MOV     R4,A
0263 900000      R     MOV     DPTR,#IO_BUFFER+01H
0266 E0                MOVX    A,@DPTR
0267 FB                MOV     R3,A
0268 A3                INC     DPTR
0269 E0                MOVX    A,@DPTR
026A FA                MOV     R2,A
026B A3                INC     DPTR
026C E0                MOVX    A,@DPTR
026D F9                MOV     R1,A
026E 8D82              MOV     DPL,R5
0270 8C83              MOV     DPH,R4
0272 120000      E     LCALL   ?C?CLDOPTR
0275 14                DEC     A
0276 601E              JZ      ?C0016
0278 04                INC     A
0279 6003              JZ      $ + 5H
027B 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 212
                                           ; SOURCE LINE # 213
027E         ?C0015:
                                           ; SOURCE LINE # 214
027E 8F82              MOV     DPL,R7
0280 8E83              MOV     DPH,R6
0282 A3                INC     DPTR
0283 A3                INC     DPTR
0284 120000      E     LCALL   ?C?CLDOPTR
0287 F590              MOV     P1,A
                                           ; SOURCE LINE # 215
0289 8F82              MOV     DPL,R7
028B 8E83              MOV     DPH,R6
028D A3                INC     DPTR
028E A3                INC     DPTR
028F A3                INC     DPTR
0290 120000      E     LCALL   ?C?CLDOPTR
0293 F5A0              MOV     P2,A
                                           ; SOURCE LINE # 216
0295 22                RET     
                                           ; SOURCE LINE # 217
0296         ?C0016:
                                           ; SOURCE LINE # 218
0296 900000      R     MOV     DPTR,#temp
0299 E5E2              MOV     A,XBR1
029B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 219
029C 900000      R     MOV     DPTR,#gOffset
029F E0                MOVX    A,@DPTR
02A0 2402              ADD     A,#02H
02A2 FF                MOV     R7,A
02A3 E4                CLR     A
02A4 33                RLC     A
02A5 FE                MOV     R6,A
02A6 900000      R     MOV     DPTR,#IO_BUFFER+01H
02A9 E0                MOVX    A,@DPTR
02AA FB                MOV     R3,A
02AB A3                INC     DPTR
02AC E0                MOVX    A,@DPTR
02AD FA                MOV     R2,A
02AE A3                INC     DPTR
02AF E0                MOVX    A,@DPTR
02B0 F9                MOV     R1,A
02B1 8F82              MOV     DPL,R7
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 36  

02B3 8E83              MOV     DPH,R6
02B5 120000      E     LCALL   ?C?CLDOPTR
02B8 30E00F            JNB     ACC.0,?C0017
                                           ; SOURCE LINE # 220
                                           ; SOURCE LINE # 221
02BB 53E27F            ANL     XBR1,#07FH
                                           ; SOURCE LINE # 222
02BE E4                CLR     A
02BF FF                MOV     R7,A
02C0 120000      E     LCALL   _Timer0_Init
                                           ; SOURCE LINE # 223
02C3 7F02              MOV     R7,#02H
02C5 7E00              MOV     R6,#00H
02C7 120000      E     LCALL   _T0_Wait
                                           ; SOURCE LINE # 224
02CA         ?C0017:
                                           ; SOURCE LINE # 225
02CA 900000      R     MOV     DPTR,#IO_BUFFER+01H
02CD E0                MOVX    A,@DPTR
02CE FB                MOV     R3,A
02CF A3                INC     DPTR
02D0 E0                MOVX    A,@DPTR
02D1 FA                MOV     R2,A
02D2 A3                INC     DPTR
02D3 E0                MOVX    A,@DPTR
02D4 F9                MOV     R1,A
02D5 7401              MOV     A,#01H
02D7 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 226
02DA 900000      R     MOV     DPTR,#IO_BUFFER+01H
02DD E0                MOVX    A,@DPTR
02DE FB                MOV     R3,A
02DF A3                INC     DPTR
02E0 E0                MOVX    A,@DPTR
02E1 FA                MOV     R2,A
02E2 A3                INC     DPTR
02E3 E0                MOVX    A,@DPTR
02E4 F9                MOV     R1,A
02E5 900000      R     MOV     DPTR,#gOffset
02E8 E0                MOVX    A,@DPTR
02E9 FF                MOV     R7,A
02EA F582              MOV     DPL,A
02EC 758300            MOV     DPH,#00H
02EF E4                CLR     A
02F0 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 227
02F3 7E00              MOV     R6,#00H
02F5 8F82              MOV     DPL,R7
02F7 8E83              MOV     DPH,R6
02F9 A3                INC     DPTR
02FA E590              MOV     A,P1
02FC 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 228
02FF 8F82              MOV     DPL,R7
0301 8E83              MOV     DPH,R6
0303 A3                INC     DPTR
0304 A3                INC     DPTR
0305 E5A0              MOV     A,P2
0307 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 229
030A 900000      R     MOV     DPTR,#temp
030D E0                MOVX    A,@DPTR
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 37  

030E F5E2              MOV     XBR1,A
                                           ; SOURCE LINE # 230
                                           ; SOURCE LINE # 231
0310 020000      R     LJMP    ?C0165
                                           ; SOURCE LINE # 232
                                           ; SOURCE LINE # 233
                                           ; SOURCE LINE # 234
0313         ?C0018:
                                           ; SOURCE LINE # 235
0313 900000      R     MOV     DPTR,#gOffset
0316 E0                MOVX    A,@DPTR
0317 FF                MOV     R7,A
0318 7E00              MOV     R6,#00H
031A 2401              ADD     A,#01H
031C FD                MOV     R5,A
031D EE                MOV     A,R6
031E 33                RLC     A
031F FC                MOV     R4,A
0320 900000      R     MOV     DPTR,#IO_BUFFER+01H
0323 E0                MOVX    A,@DPTR
0324 FB                MOV     R3,A
0325 A3                INC     DPTR
0326 E0                MOVX    A,@DPTR
0327 FA                MOV     R2,A
0328 A3                INC     DPTR
0329 E0                MOVX    A,@DPTR
032A F9                MOV     R1,A
032B 8D82              MOV     DPL,R5
032D 8C83              MOV     DPH,R4
032F 120000      E     LCALL   ?C?CLDOPTR
0332 14                DEC     A
0333 7003              JNZ     $ + 5H
0335 020000      R     LJMP    ?C0024
0338 04                INC     A
0339 6003              JZ      $ + 5H
033B 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 236
                                           ; SOURCE LINE # 237
033E         ?C0020:
                                           ; SOURCE LINE # 238
033E 8F82              MOV     DPL,R7
0340 8E83              MOV     DPH,R6
0342 A3                INC     DPTR
0343 A3                INC     DPTR
0344 120000      E     LCALL   ?C?CLDOPTR
0347 900000      E     MOV     DPTR,#gI2Cflags
034A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 243
034B 8F82              MOV     DPL,R7
034D 8E83              MOV     DPH,R6
034F A3                INC     DPTR
0350 A3                INC     DPTR
0351 A3                INC     DPTR
0352 120000      E     LCALL   ?C?CLDOPTR
0355 30E005            JNB     ACC.0,?C0021
0358 43C110            ORL     SMB0CF,#010H
035B 8003              SJMP    ?C0022
035D         ?C0021:
035D 53C1EF            ANL     SMB0CF,#0EFH
0360         ?C0022:
                                           ; SOURCE LINE # 244
0360 900000      R     MOV     DPTR,#gOffset
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 38  

0363 E0                MOVX    A,@DPTR
0364 2404              ADD     A,#04H
0366 FF                MOV     R7,A
0367 E4                CLR     A
0368 33                RLC     A
0369 FE                MOV     R6,A
036A 900000      R     MOV     DPTR,#IO_BUFFER+01H
036D E0                MOVX    A,@DPTR
036E FB                MOV     R3,A
036F A3                INC     DPTR
0370 E0                MOVX    A,@DPTR
0371 FA                MOV     R2,A
0372 A3                INC     DPTR
0373 E0                MOVX    A,@DPTR
0374 F9                MOV     R1,A
0375 8F82              MOV     DPL,R7
0377 8E83              MOV     DPH,R6
0379 120000      E     LCALL   ?C?CLDOPTR
037C 20E003            JB      ACC.0,$ + 6H
037F 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 245
                                           ; SOURCE LINE # 246
0382 7401              MOV     A,#01H
0384 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 247
0387 900000      R     MOV     DPTR,#IO_BUFFER+01H
038A E0                MOVX    A,@DPTR
038B FB                MOV     R3,A
038C A3                INC     DPTR
038D E0                MOVX    A,@DPTR
038E FA                MOV     R2,A
038F A3                INC     DPTR
0390 E0                MOVX    A,@DPTR
0391 F9                MOV     R1,A
0392 900000      R     MOV     DPTR,#gOffset
0395 E0                MOVX    A,@DPTR
0396 F582              MOV     DPL,A
0398 758300            MOV     DPH,#00H
039B E4                CLR     A
039C 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 248
039F 120000      E     LCALL   clearSDA
03A2 900000      R     MOV     DPTR,#gOffset
03A5 E0                MOVX    A,@DPTR
03A6 2401              ADD     A,#01H
03A8 FD                MOV     R5,A
03A9 E4                CLR     A
03AA 33                RLC     A
03AB FC                MOV     R4,A
03AC 900000      R     MOV     DPTR,#IO_BUFFER+01H
03AF E0                MOVX    A,@DPTR
03B0 FB                MOV     R3,A
03B1 A3                INC     DPTR
03B2 E0                MOVX    A,@DPTR
03B3 FA                MOV     R2,A
03B4 A3                INC     DPTR
03B5 E0                MOVX    A,@DPTR
03B6 F9                MOV     R1,A
03B7 8D82              MOV     DPL,R5
03B9 8C83              MOV     DPH,R4
03BB         ?C0158:
03BB EF                MOV     A,R7
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 39  

03BC         ?C0160:
03BC 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 249
03BF         ?C0161:
                                           ; SOURCE LINE # 250
                                           ; SOURCE LINE # 251
03BF 020000      R     LJMP    ?C0165
                                           ; SOURCE LINE # 252
03C2         ?C0024:
                                           ; SOURCE LINE # 253
03C2 900000      R     MOV     DPTR,#IO_BUFFER+01H
03C5 E0                MOVX    A,@DPTR
03C6 FB                MOV     R3,A
03C7 A3                INC     DPTR
03C8 E0                MOVX    A,@DPTR
03C9 FA                MOV     R2,A
03CA A3                INC     DPTR
03CB E0                MOVX    A,@DPTR
03CC F9                MOV     R1,A
03CD 7401              MOV     A,#01H
03CF 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 254
03D2 900000      R     MOV     DPTR,#IO_BUFFER+01H
03D5 E0                MOVX    A,@DPTR
03D6 FB                MOV     R3,A
03D7 A3                INC     DPTR
03D8 E0                MOVX    A,@DPTR
03D9 FA                MOV     R2,A
03DA A3                INC     DPTR
03DB E0                MOVX    A,@DPTR
03DC F9                MOV     R1,A
03DD 900000      R     MOV     DPTR,#gOffset
03E0 E0                MOVX    A,@DPTR
03E1 FF                MOV     R7,A
03E2 F582              MOV     DPL,A
03E4 758300            MOV     DPH,#00H
03E7 E4                CLR     A
03E8 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 255
03EB 900000      E     MOV     DPTR,#gI2Cflags
03EE E0                MOVX    A,@DPTR
03EF FE                MOV     R6,A
03F0 EF                MOV     A,R7
03F1 F582              MOV     DPL,A
03F3 758300            MOV     DPH,#00H
03F6 A3                INC     DPTR
03F7 EE                MOV     A,R6
03F8 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 256
03FB E5C1              MOV     A,SMB0CF
03FD 5410              ANL     A,#010H
03FF C4                SWAP    A
0400 540F              ANL     A,#0FH
0402 FF                MOV     R7,A
0403 900000      R     MOV     DPTR,#gOffset
0406 E0                MOVX    A,@DPTR
                                           ; SOURCE LINE # 257
                                           ; SOURCE LINE # 258
0407 020000      R     LJMP    ?C0163
                                           ; SOURCE LINE # 259
                                           ; SOURCE LINE # 260
                                           ; SOURCE LINE # 261
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 40  

040A         ?C0025:
                                           ; SOURCE LINE # 262
040A 900000      R     MOV     DPTR,#gOffset
040D E0                MOVX    A,@DPTR
040E 2401              ADD     A,#01H
0410 FF                MOV     R7,A
0411 E4                CLR     A
0412 33                RLC     A
0413 FE                MOV     R6,A
0414 900000      R     MOV     DPTR,#IO_BUFFER+01H
0417 E0                MOVX    A,@DPTR
0418 FB                MOV     R3,A
0419 A3                INC     DPTR
041A E0                MOVX    A,@DPTR
041B FA                MOV     R2,A
041C A3                INC     DPTR
041D E0                MOVX    A,@DPTR
041E F9                MOV     R1,A
041F 8F82              MOV     DPL,R7
0421 8E83              MOV     DPH,R6
0423 120000      E     LCALL   ?C?CLDOPTR
0426 14                DEC     A
0427 604F              JZ      ?C0028
0429 04                INC     A
042A 6003              JZ      $ + 5H
042C 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 264
042F         ?C0027:
                                           ; SOURCE LINE # 265
042F 900000      R     MOV     DPTR,#gOffset
0432 E0                MOVX    A,@DPTR
0433 F582              MOV     DPL,A
0435 758300            MOV     DPH,#00H
0438 A3                INC     DPTR
0439 A3                INC     DPTR
043A 120000      E     LCALL   ?C?CLDOPTR
043D FC                MOV     R4,A
043E E4                CLR     A
043F 120000      E     LCALL   ?C?FCASTC
0442 C004              PUSH    AR4
0444 C005              PUSH    AR5
0446 C006              PUSH    AR6
0448 C007              PUSH    AR7
044A E4                CLR     A
044B FB                MOV     R3,A
044C FA                MOV     R2,A
044D 7940              MOV     R1,#040H
044F 7840              MOV     R0,#040H
0451 900000      E     MOV     DPTR,#gTimer1ClkFreq
0454 E0                MOVX    A,@DPTR
0455 FC                MOV     R4,A
0456 A3                INC     DPTR
0457 E0                MOVX    A,@DPTR
0458 FD                MOV     R5,A
0459 A3                INC     DPTR
045A E0                MOVX    A,@DPTR
045B FE                MOV     R6,A
045C A3                INC     DPTR
045D E0                MOVX    A,@DPTR
045E FF                MOV     R7,A
045F 120000      E     LCALL   ?C?FPDIV
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 41  

0462 D003              POP     AR3
0464 D002              POP     AR2
0466 D001              POP     AR1
0468 D000              POP     AR0
046A 120000      E     LCALL   ?C?FPDIV
046D 900000      E     MOV     DPTR,#gSMBusClkFreq
0470 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 266
0473 C28E              CLR     TR1
                                           ; SOURCE LINE # 267
0475 020000      E     LJMP    Timer1_Init
                                           ; SOURCE LINE # 268
                                           ; SOURCE LINE # 269
0478         ?C0028:
                                           ; SOURCE LINE # 270
0478 900000      R     MOV     DPTR,#IO_BUFFER+01H
047B E0                MOVX    A,@DPTR
047C FB                MOV     R3,A
047D A3                INC     DPTR
047E E0                MOVX    A,@DPTR
047F FA                MOV     R2,A
0480 A3                INC     DPTR
0481 E0                MOVX    A,@DPTR
0482 F9                MOV     R1,A
0483 7401              MOV     A,#01H
0485 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 271
0488 900000      R     MOV     DPTR,#IO_BUFFER+01H
048B E0                MOVX    A,@DPTR
048C FB                MOV     R3,A
048D A3                INC     DPTR
048E E0                MOVX    A,@DPTR
048F FA                MOV     R2,A
0490 A3                INC     DPTR
0491 E0                MOVX    A,@DPTR
0492 F9                MOV     R1,A
0493 900000      R     MOV     DPTR,#gOffset
0496 E0                MOVX    A,@DPTR
0497 F582              MOV     DPL,A
0499 758300            MOV     DPH,#00H
049C E4                CLR     A
049D 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 272
04A0 7B00              MOV     R3,#00H
04A2 7A24              MOV     R2,#024H
04A4 7974              MOV     R1,#074H
04A6 7849              MOV     R0,#049H
04A8 900000      E     MOV     DPTR,#gTimer1ClkFreq
04AB E0                MOVX    A,@DPTR
04AC FC                MOV     R4,A
04AD A3                INC     DPTR
04AE E0                MOVX    A,@DPTR
04AF FD                MOV     R5,A
04B0 A3                INC     DPTR
04B1 E0                MOVX    A,@DPTR
04B2 FE                MOV     R6,A
04B3 A3                INC     DPTR
04B4 E0                MOVX    A,@DPTR
04B5 FF                MOV     R7,A
04B6 120000      E     LCALL   ?C?FPDIV
04B9 E4                CLR     A
04BA FB                MOV     R3,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 42  

04BB FA                MOV     R2,A
04BC 7940              MOV     R1,#040H
04BE 7840              MOV     R0,#040H
04C0 120000      E     LCALL   ?C?FPDIV
04C3 120000      E     LCALL   ?C?CASTF
04C6 900000      R     MOV     DPTR,#gOffset
04C9 E0                MOVX    A,@DPTR
04CA FE                MOV     R6,A
04CB 2401              ADD     A,#01H
04CD FD                MOV     R5,A
04CE E4                CLR     A
04CF 33                RLC     A
04D0 FC                MOV     R4,A
04D1 900000      R     MOV     DPTR,#IO_BUFFER+01H
04D4 E0                MOVX    A,@DPTR
04D5 FB                MOV     R3,A
04D6 A3                INC     DPTR
04D7 E0                MOVX    A,@DPTR
04D8 FA                MOV     R2,A
04D9 A3                INC     DPTR
04DA E0                MOVX    A,@DPTR
04DB F9                MOV     R1,A
04DC 8D82              MOV     DPL,R5
04DE 8C83              MOV     DPH,R4
04E0 EF                MOV     A,R7
04E1 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 273
04E4 E58D              MOV     A,TH1
04E6 F4                CPL     A
04E7 04                INC     A
04E8 FF                MOV     R7,A
04E9 EE                MOV     A,R6
04EA         ?C0163:
04EA F582              MOV     DPL,A
04EC 758300            MOV     DPH,#00H
04EF A3                INC     DPTR
04F0 A3                INC     DPTR
04F1 EF                MOV     A,R7
                                           ; SOURCE LINE # 274
                                           ; SOURCE LINE # 275
04F2 020000      R     LJMP    ?C0166
                                           ; SOURCE LINE # 276
                                           ; SOURCE LINE # 277
                                           ; SOURCE LINE # 278
04F5         ?C0029:
                                           ; SOURCE LINE # 279
04F5 900000      R     MOV     DPTR,#gOffset
04F8 E0                MOVX    A,@DPTR
04F9 FD                MOV     R5,A
04FA 7C00              MOV     R4,#00H
04FC 2401              ADD     A,#01H
04FE FF                MOV     R7,A
04FF EC                MOV     A,R4
0500 33                RLC     A
0501 FE                MOV     R6,A
0502 900000      R     MOV     DPTR,#IO_BUFFER+01H
0505 E0                MOVX    A,@DPTR
0506 FB                MOV     R3,A
0507 A3                INC     DPTR
0508 E0                MOVX    A,@DPTR
0509 FA                MOV     R2,A
050A A3                INC     DPTR
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 43  

050B E0                MOVX    A,@DPTR
050C F9                MOV     R1,A
050D 8F82              MOV     DPL,R7
050F 8E83              MOV     DPH,R6
0511 120000      E     LCALL   ?C?CLDOPTR
0514 5401              ANL     A,#01H
0516 14                DEC     A
0517 604C              JZ      ?C0032
0519 04                INC     A
051A 6003              JZ      $ + 5H
051C 020000      R     LJMP    ?C0030
                                           ; SOURCE LINE # 280
                                           ; SOURCE LINE # 281
051F         ?C0031:
                                           ; SOURCE LINE # 282
051F ED                MOV     A,R5
0520 2401              ADD     A,#01H
0522 FF                MOV     R7,A
0523 E4                CLR     A
0524 3C                ADDC    A,R4
0525 FE                MOV     R6,A
0526 900000      R     MOV     DPTR,#IO_BUFFER+01H
0529 E0                MOVX    A,@DPTR
052A FB                MOV     R3,A
052B A3                INC     DPTR
052C E0                MOVX    A,@DPTR
052D FA                MOV     R2,A
052E A3                INC     DPTR
052F E0                MOVX    A,@DPTR
0530 F9                MOV     R1,A
0531 8F82              MOV     DPL,R7
0533 8E83              MOV     DPH,R6
0535 120000      E     LCALL   ?C?CLDOPTR
0538 54FE              ANL     A,#0FEH
053A FF                MOV     R7,A
053B ED                MOV     A,R5
053C 2402              ADD     A,#02H
053E FD                MOV     R5,A
053F E4                CLR     A
0540 3C                ADDC    A,R4
0541 FC                MOV     R4,A
0542 8D82              MOV     DPL,R5
0544 8C83              MOV     DPH,R4
0546 120000      E     LCALL   ?C?CLDOPTR
0549 900000      E     MOV     DPTR,#?_i2c_write?BYTE+04H
054C F0                MOVX    @DPTR,A
054D 900000      R     MOV     DPTR,#gOffset
0550 E0                MOVX    A,@DPTR
0551 F582              MOV     DPL,A
0553 758300            MOV     DPH,#00H
0556 A3                INC     DPTR
0557 A3                INC     DPTR
0558 A3                INC     DPTR
0559 120000      E     LCALL   ?C?CLDOPTR
055C 900000      E     MOV     DPTR,#?_i2c_write?BYTE+05H
055F F0                MOVX    @DPTR,A
0560 120000      E     LCALL   _i2c_write
                                           ; SOURCE LINE # 284
0563 804A              SJMP    ?C0030
                                           ; SOURCE LINE # 285
0565         ?C0032:
                                           ; SOURCE LINE # 286
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 44  

0565 900000      R     MOV     DPTR,#gOffset
0568 E0                MOVX    A,@DPTR
0569 FD                MOV     R5,A
056A 7C00              MOV     R4,#00H
056C 2401              ADD     A,#01H
056E FF                MOV     R7,A
056F EC                MOV     A,R4
0570 33                RLC     A
0571 FE                MOV     R6,A
0572 900000      R     MOV     DPTR,#IO_BUFFER+01H
0575 E0                MOVX    A,@DPTR
0576 FB                MOV     R3,A
0577 A3                INC     DPTR
0578 E0                MOVX    A,@DPTR
0579 FA                MOV     R2,A
057A A3                INC     DPTR
057B E0                MOVX    A,@DPTR
057C F9                MOV     R1,A
057D 8F82              MOV     DPL,R7
057F 8E83              MOV     DPH,R6
0581 120000      E     LCALL   ?C?CLDOPTR
0584 54FE              ANL     A,#0FEH
0586 FF                MOV     R7,A
0587 ED                MOV     A,R5
0588 2402              ADD     A,#02H
058A FD                MOV     R5,A
058B EC                MOV     A,R4
058C 33                RLC     A
058D FC                MOV     R4,A
058E 8D82              MOV     DPL,R5
0590 8C83              MOV     DPH,R4
0592 120000      E     LCALL   ?C?CLDOPTR
0595 900000      E     MOV     DPTR,#?_i2c_read?BYTE+04H
0598 F0                MOVX    @DPTR,A
0599 900000      R     MOV     DPTR,#gOffset
059C E0                MOVX    A,@DPTR
059D F582              MOV     DPL,A
059F 758300            MOV     DPH,#00H
05A2 A3                INC     DPTR
05A3 A3                INC     DPTR
05A4 A3                INC     DPTR
05A5 120000      E     LCALL   ?C?CLDOPTR
05A8 900000      E     MOV     DPTR,#?_i2c_read?BYTE+05H
05AB F0                MOVX    @DPTR,A
05AC 120000      E     LCALL   _i2c_read
                                           ; SOURCE LINE # 288
                                           ; SOURCE LINE # 289
05AF         ?C0030:
                                           ; SOURCE LINE # 290
05AF 900000      R     MOV     DPTR,#internalCall
05B2 E0                MOVX    A,@DPTR
05B3 7002              JNZ     ?C0149
05B5 A3                INC     DPTR
05B6 E0                MOVX    A,@DPTR
05B7         ?C0149:
05B7 6003              JZ      $ + 5H
05B9 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 291
05BC         ?C0162:
                                           ; SOURCE LINE # 292
05BC 020000      R     LJMP    ?C0165
                                           ; SOURCE LINE # 293
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 45  

05BF         ?C0034:
                                           ; SOURCE LINE # 294
05BF 900000      R     MOV     DPTR,#gOffset
05C2 E0                MOVX    A,@DPTR
05C3 2401              ADD     A,#01H
05C5 FF                MOV     R7,A
05C6 E4                CLR     A
05C7 33                RLC     A
05C8 FE                MOV     R6,A
05C9 900000      R     MOV     DPTR,#IO_BUFFER+01H
05CC E0                MOVX    A,@DPTR
05CD FB                MOV     R3,A
05CE A3                INC     DPTR
05CF E0                MOVX    A,@DPTR
05D0 FA                MOV     R2,A
05D1 A3                INC     DPTR
05D2 E0                MOVX    A,@DPTR
05D3 F9                MOV     R1,A
05D4 8F82              MOV     DPL,R7
05D6 8E83              MOV     DPH,R6
05D8 120000      E     LCALL   ?C?CLDOPTR
05DB 14                DEC     A
05DC 6003              JZ      $ + 5H
05DE 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 296
                                           ; SOURCE LINE # 304
                                           ; SOURCE LINE # 305
05E1         ?C0037:
                                           ; SOURCE LINE # 311
05E1 7401              MOV     A,#01H
05E3 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 312
05E6 900000      R     MOV     DPTR,#IO_BUFFER+01H
05E9 E0                MOVX    A,@DPTR
05EA FB                MOV     R3,A
05EB A3                INC     DPTR
05EC E0                MOVX    A,@DPTR
05ED FA                MOV     R2,A
05EE A3                INC     DPTR
05EF E0                MOVX    A,@DPTR
05F0 F9                MOV     R1,A
05F1 900000      R     MOV     DPTR,#gOffset
05F4 E0                MOVX    A,@DPTR
05F5 F582              MOV     DPL,A
05F7 758300            MOV     DPH,#00H
05FA 74FA              MOV     A,#0FAH
05FC         ?C0164:
                                           ; SOURCE LINE # 314
                                           ; SOURCE LINE # 315
05FC 020000      R     LJMP    ?C0166
                                           ; SOURCE LINE # 316
                                           ; SOURCE LINE # 317
                                           ; SOURCE LINE # 318
05FF         ?C0038:
                                           ; SOURCE LINE # 319
05FF 900000      R     MOV     DPTR,#gOffset
0602 E0                MOVX    A,@DPTR
0603 2401              ADD     A,#01H
0605 FF                MOV     R7,A
0606 E4                CLR     A
0607 33                RLC     A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 46  

0608 FE                MOV     R6,A
0609 900000      R     MOV     DPTR,#IO_BUFFER+01H
060C E0                MOVX    A,@DPTR
060D FB                MOV     R3,A
060E A3                INC     DPTR
060F E0                MOVX    A,@DPTR
0610 FA                MOV     R2,A
0611 A3                INC     DPTR
0612 E0                MOVX    A,@DPTR
0613 F9                MOV     R1,A
0614 8F82              MOV     DPL,R7
0616 8E83              MOV     DPH,R6
0618 120000      E     LCALL   ?C?CLDOPTR
061B 14                DEC     A
061C 6003              JZ      $ + 5H
061E 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 321
                                           ; SOURCE LINE # 325
                                           ; SOURCE LINE # 326
0621         ?C0041:
                                           ; SOURCE LINE # 333
0621 900000      R     MOV     DPTR,#IO_BUFFER+01H
0624 E0                MOVX    A,@DPTR
0625 FB                MOV     R3,A
0626 A3                INC     DPTR
0627 E0                MOVX    A,@DPTR
0628 FA                MOV     R2,A
0629 A3                INC     DPTR
062A E0                MOVX    A,@DPTR
062B F9                MOV     R1,A
062C 7401              MOV     A,#01H
062E 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 334
0631 900000      R     MOV     DPTR,#IO_BUFFER+01H
0634 E0                MOVX    A,@DPTR
0635 FB                MOV     R3,A
0636 A3                INC     DPTR
0637 E0                MOVX    A,@DPTR
0638 FA                MOV     R2,A
0639 A3                INC     DPTR
063A E0                MOVX    A,@DPTR
063B F9                MOV     R1,A
063C 900000      R     MOV     DPTR,#gOffset
063F E0                MOVX    A,@DPTR
0640 F582              MOV     DPL,A
0642 758300            MOV     DPH,#00H
0645 74FA              MOV     A,#0FAH
0647 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 335
064A 7B00              MOV     R3,#00H
064C 7A24              MOV     R2,#024H
064E 7974              MOV     R1,#074H
0650 7849              MOV     R0,#049H
0652 900000      E     MOV     DPTR,#gSysClkFreq
0655 E0                MOVX    A,@DPTR
0656 FC                MOV     R4,A
0657 A3                INC     DPTR
0658 E0                MOVX    A,@DPTR
0659 FD                MOV     R5,A
065A A3                INC     DPTR
065B E0                MOVX    A,@DPTR
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 47  

065C FE                MOV     R6,A
065D A3                INC     DPTR
065E E0                MOVX    A,@DPTR
065F FF                MOV     R7,A
0660 120000      E     LCALL   ?C?FPDIV
0663 120000      E     LCALL   ?C?CASTF
0666 900000      R     MOV     DPTR,#gOffset
0669 E0                MOVX    A,@DPTR
066A FE                MOV     R6,A
066B 2401              ADD     A,#01H
066D FD                MOV     R5,A
066E E4                CLR     A
066F 33                RLC     A
0670 FC                MOV     R4,A
0671 900000      R     MOV     DPTR,#IO_BUFFER+01H
0674 E0                MOVX    A,@DPTR
0675 FB                MOV     R3,A
0676 A3                INC     DPTR
0677 E0                MOVX    A,@DPTR
0678 FA                MOV     R2,A
0679 A3                INC     DPTR
067A E0                MOVX    A,@DPTR
067B F9                MOV     R1,A
067C 8D82              MOV     DPL,R5
067E 8C83              MOV     DPH,R4
0680 EF                MOV     A,R7
0681 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 336
0684 EE                MOV     A,R6
0685 F582              MOV     DPL,A
0687 758300            MOV     DPH,#00H
068A A3                INC     DPTR
068B A3                INC     DPTR
068C E5A2              MOV     A,SPI0CKR
068E         ?C0166:
068E 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 338
                                           ; SOURCE LINE # 339
0691 8042              SJMP    ?C0167
                                           ; SOURCE LINE # 340
                                           ; SOURCE LINE # 341
                                           ; SOURCE LINE # 342
0693         ?C0042:
                                           ; SOURCE LINE # 343
0693 900000      R     MOV     DPTR,#gOffset
0696 E0                MOVX    A,@DPTR
0697 FF                MOV     R7,A
0698 7E00              MOV     R6,#00H
069A 2402              ADD     A,#02H
069C FD                MOV     R5,A
069D EE                MOV     A,R6
069E 33                RLC     A
069F FC                MOV     R4,A
06A0 900000      R     MOV     DPTR,#IO_BUFFER+01H
06A3 E0                MOVX    A,@DPTR
06A4 FB                MOV     R3,A
06A5 A3                INC     DPTR
06A6 E0                MOVX    A,@DPTR
06A7 FA                MOV     R2,A
06A8 A3                INC     DPTR
06A9 E0                MOVX    A,@DPTR
06AA F9                MOV     R1,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 48  

06AB 8D82              MOV     DPL,R5
06AD 8C83              MOV     DPH,R4
06AF 120000      E     LCALL   ?C?CLDOPTR
06B2 900000      R     MOV     DPTR,#temp
06B5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 344
06B6 8F82              MOV     DPL,R7
06B8 8E83              MOV     DPH,R6
06BA A3                INC     DPTR
06BB 120000      E     LCALL   ?C?CLDOPTR
06BE FF                MOV     R7,A
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 379
06BF         ?C0043:
                                           ; SOURCE LINE # 380
06BF 900000      R     MOV     DPTR,#internalCall
06C2 E0                MOVX    A,@DPTR
06C3 7002              JNZ     ?C0150
06C5 A3                INC     DPTR
06C6 E0                MOVX    A,@DPTR
06C7         ?C0150:
06C7 6003              JZ      $ + 5H
06C9 020000      R     LJMP    ?C0057
06CC 900000      R     MOV     DPTR,#temp
06CF E0                MOVX    A,@DPTR
06D0 7003              JNZ     $ + 5H
06D2 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 381
06D5         ?C0165:
06D5         ?C0167:
06D5 020000      E     LJMP    SendPacket
                                           ; SOURCE LINE # 382
                                           ; SOURCE LINE # 383
06D8         ?C0045:
                                           ; SOURCE LINE # 386
06D8 E4                CLR     A
06D9 900000      R     MOV     DPTR,#gMockHIDFIFOChannel
06DC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 387
06DD 900000      R     MOV     DPTR,#gMockHIDFIFOCh1
06E0 04                INC     A
06E1 F0                MOVX    @DPTR,A
06E2 A3                INC     DPTR
06E3 E4                CLR     A
06E4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 388
06E5 A3                INC     DPTR
06E6 7402              MOV     A,#02H
06E8 F0                MOVX    @DPTR,A
06E9 A3                INC     DPTR
06EA E4                CLR     A
06EB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 389
06EC A3                INC     DPTR
06ED 7403              MOV     A,#03H
06EF F0                MOVX    @DPTR,A
06F0 A3                INC     DPTR
06F1 E4                CLR     A
06F2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 390
06F3 A3                INC     DPTR
06F4 7404              MOV     A,#04H
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 49  

06F6 F0                MOVX    @DPTR,A
06F7 A3                INC     DPTR
06F8 E4                CLR     A
06F9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 391
06FA 900000      R     MOV     DPTR,#gOS21numIntServiced
06FD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 393
06FE 900000      R     MOV     DPTR,#gLIS2DHnumIntServiced
0701 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 394
0702 900000      R     MOV     DPTR,#gMockHID2X
0705 7410              MOV     A,#010H
0707 F0                MOVX    @DPTR,A
0708 A3                INC     DPTR
0709 7420              MOV     A,#020H
070B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 395
070C A3                INC     DPTR
070D 7430              MOV     A,#030H
070F F0                MOVX    @DPTR,A
0710 A3                INC     DPTR
0711 7440              MOV     A,#040H
0713 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 396
0714 A3                INC     DPTR
0715 7450              MOV     A,#050H
0717 F0                MOVX    @DPTR,A
0718 A3                INC     DPTR
0719 7460              MOV     A,#060H
071B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 398
071C 900000      R     MOV     DPTR,#gOffset
071F E0                MOVX    A,@DPTR
0720 2401              ADD     A,#01H
0722 FF                MOV     R7,A
0723 E4                CLR     A
0724 33                RLC     A
0725 FE                MOV     R6,A
0726 900000      R     MOV     DPTR,#IO_BUFFER+01H
0729 E0                MOVX    A,@DPTR
072A FB                MOV     R3,A
072B A3                INC     DPTR
072C E0                MOVX    A,@DPTR
072D FA                MOV     R2,A
072E A3                INC     DPTR
072F E0                MOVX    A,@DPTR
0730 F9                MOV     R1,A
0731 8F82              MOV     DPL,R7
0733 8E83              MOV     DPH,R6
0735 120000      E     LCALL   ?C?CLDOPTR
0738 FF                MOV     R7,A
0739 24FE              ADD     A,#0FEH
073B 6034              JZ      ?C0052
073D 14                DEC     A
073E 6036              JZ      ?C0053
0740 14                DEC     A
0741 603A              JZ      ?C0054
0743 14                DEC     A
0744 603E              JZ      ?C0055
0746 14                DEC     A
0747 6042              JZ      ?C0056
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 50  

0749 8000              SJMP    ?C0049
                                           ; SOURCE LINE # 399
                                           ; SOURCE LINE # 400
                                           ; SOURCE LINE # 401
                                           ; SOURCE LINE # 402
074B         ?C0049:
                                           ; SOURCE LINE # 403
074B E4                CLR     A
074C 900000      R     MOV     DPTR,#gMockHIDFIFOChannels
074F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 405
0750 900000      R     MOV     DPTR,#gMockHIDreport2
0753 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 407
0754 EF                MOV     A,R7
0755 24FF              ADD     A,#0FFH
0757 92A8              MOV     EX0,C
                                           ; SOURCE LINE # 410
0759 EF                MOV     A,R7
075A 7009              JNZ     ?C0050
                                           ; SOURCE LINE # 412
075C FB                MOV     R3,A
075D FD                MOV     R5,A
075E FF                MOV     R7,A
075F 120000      E     LCALL   _lis2dh_configure_FIFO
                                           ; SOURCE LINE # 415
0762 C2AA              CLR     EX1
                                           ; SOURCE LINE # 417
0764 22                RET     
0765         ?C0050:
                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 439
0765 7B1A              MOV     R3,#01AH
0767 E4                CLR     A
0768 FD                MOV     R5,A
0769 7F02              MOV     R7,#02H
076B 120000      E     LCALL   _lis2dh_configure_FIFO
                                           ; SOURCE LINE # 484
076E D2AA              SETB    EX1
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 488
0770 22                RET     
                                           ; SOURCE LINE # 489
0771         ?C0052:
                                           ; SOURCE LINE # 490
0771 900000      R     MOV     DPTR,#gMockHIDFIFOChannels
                                           ; SOURCE LINE # 491
                                           ; SOURCE LINE # 492
0774 8018              SJMP    ?C0168
                                           ; SOURCE LINE # 493
0776         ?C0053:
                                           ; SOURCE LINE # 494
0776 900000      R     MOV     DPTR,#gMockHIDFIFOChannels
0779 7402              MOV     A,#02H
                                           ; SOURCE LINE # 495
                                           ; SOURCE LINE # 496
077B 8013              SJMP    ?C0171
                                           ; SOURCE LINE # 497
077D         ?C0054:
                                           ; SOURCE LINE # 498
077D 900000      R     MOV     DPTR,#gMockHIDFIFOChannels
0780 7403              MOV     A,#03H
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 51  

0782         ?C0169:
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 500
0782 800C              SJMP    ?C0171
                                           ; SOURCE LINE # 501
0784         ?C0055:
                                           ; SOURCE LINE # 502
0784 900000      R     MOV     DPTR,#gMockHIDFIFOChannels
0787 7404              MOV     A,#04H
0789         ?C0170:
                                           ; SOURCE LINE # 503
                                           ; SOURCE LINE # 504
0789 8005              SJMP    ?C0171
                                           ; SOURCE LINE # 506
078B         ?C0056:
                                           ; SOURCE LINE # 507
078B 900000      R     MOV     DPTR,#gMockHIDreport2
078E         ?C0168:
078E 7401              MOV     A,#01H
0790         ?C0171:
0790 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 508
0791 D2A8              SETB    EX0
                                           ; SOURCE LINE # 509
                                           ; SOURCE LINE # 511
                                           ; SOURCE LINE # 512
                                           ; SOURCE LINE # 513
                                           ; SOURCE LINE # 514
0793         ?C0057:
0793 22                RET     
             ; FUNCTION _OUT_REPORT_HANDLER (END)

             ; FUNCTION Setup_IO_BUFFER (BEGIN)
                                           ; SOURCE LINE # 516
                                           ; SOURCE LINE # 517
                                           ; SOURCE LINE # 518
0000 900000      R     MOV     DPTR,#IO_BUFFER+01H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
0006 A3                INC     DPTR
0007 7400        E     MOV     A,#HIGH IO_PACKET
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B 7400        E     MOV     A,#LOW IO_PACKET
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 520
000E 900000      R     MOV     DPTR,#IO_BUFFER
0011 7440              MOV     A,#040H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 524
0014 22                RET     
             ; FUNCTION Setup_IO_BUFFER (END)

             ; FUNCTION INT0_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
                                           ; SOURCE LINE # 532
                                           ; SOURCE LINE # 534
0006 900000      R     MOV     DPTR,#gOS21ready
0009 7401              MOV     A,#01H
000B F0                MOVX    @DPTR,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 52  

                                           ; SOURCE LINE # 537
000C 900000      R     MOV     DPTR,#gLIS2DHready
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 539
0010 D082              POP     DPL
0012 D083              POP     DPH
0014 D0E0              POP     ACC
0016 32                RETI    
             ; FUNCTION INT0_ISR (END)

             ; FUNCTION INT1_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
                                           ; SOURCE LINE # 548
                                           ; SOURCE LINE # 557
0006 900000      R     MOV     DPTR,#gLIS2DHready
0009 7401              MOV     A,#01H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 562
000C D082              POP     DPL
000E D083              POP     DPH
0010 D0E0              POP     ACC
0012 32                RETI    
             ; FUNCTION INT1_ISR (END)

             ; FUNCTION testOS21IntTiming (BEGIN)
                                           ; SOURCE LINE # 565
                                           ; SOURCE LINE # 566
                                           ; SOURCE LINE # 573
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#gOS21ready
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 575
0005 900000      R     MOV     DPTR,#blockArr+05H
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 576
0009 900000      E     MOV     DPTR,#gMAX30101deviceAddress
000C E0                MOVX    A,@DPTR
000D 54FE              ANL     A,#0FEH
000F FF                MOV     R7,A
0010 7B01              MOV     R3,#01H
0012 7A00        R     MOV     R2,#HIGH blockArr
0014 7900        R     MOV     R1,#LOW blockArr
0016 900000      E     MOV     DPTR,#?_i2c_read?BYTE+04H
0019 7401              MOV     A,#01H
001B F0                MOVX    @DPTR,A
001C A3                INC     DPTR
001D F0                MOVX    @DPTR,A
001E 120000      E     LCALL   _i2c_read
                                           ; SOURCE LINE # 577
0021 900000      R     MOV     DPTR,#blockArr+05H
0024 7405              MOV     A,#05H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 578
0027 E4                CLR     A
0028 900000      R     MOV     DPTR,#outer
002B F0                MOVX    @DPTR,A
002C         ?C0061:
                                           ; SOURCE LINE # 579
002C 900000      E     MOV     DPTR,#gMAX30101deviceAddress
002F E0                MOVX    A,@DPTR
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 53  

0030 54FE              ANL     A,#0FEH
0032 FF                MOV     R7,A
0033 7B01              MOV     R3,#01H
0035 7A00        R     MOV     R2,#HIGH blockArr
0037 7900        R     MOV     R1,#LOW blockArr
0039 900000      E     MOV     DPTR,#?_i2c_read?BYTE+04H
003C 7401              MOV     A,#01H
003E F0                MOVX    @DPTR,A
003F A3                INC     DPTR
0040 F0                MOVX    @DPTR,A
0041 120000      E     LCALL   _i2c_read
                                           ; SOURCE LINE # 580
0044 900000      R     MOV     DPTR,#outer
0047 E0                MOVX    A,@DPTR
0048 04                INC     A
0049 F0                MOVX    @DPTR,A
004A E0                MOVX    A,@DPTR
004B C3                CLR     C
004C 943C              SUBB    A,#03CH
004E 40DC              JC      ?C0061
0050         ?C0062:
                                           ; SOURCE LINE # 581
0050 020000      E     LJMP    SendPacket
             ; FUNCTION testOS21IntTiming (END)

             ; FUNCTION readOS21 (BEGIN)
                                           ; SOURCE LINE # 592
                                           ; SOURCE LINE # 593
                                           ; SOURCE LINE # 603
0000 C200        R     CLR     singleSample
                                           ; SOURCE LINE # 604
0002 D200        R     SETB    singleReport
                                           ; SOURCE LINE # 637
0004 300002      R     JNB     singleSample,?C0065
                                           ; SOURCE LINE # 638
0007 D200        R     SETB    singleReport
                                           ; SOURCE LINE # 639
0009         ?C0065:
                                           ; SOURCE LINE # 640
0009 E4                CLR     A
000A 900000      R     MOV     DPTR,#gOS21ready
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 644
000E 300004      R     JNB     singleSample,?C0066
0011 7F06              MOV     R7,#06H
0013 8010              SJMP    ?C0067
0015         ?C0066:
0015 300004      R     JNB     singleReport,?C0068
0018 7F3C              MOV     R7,#03CH
001A 8009              SJMP    ?C0069
001C         ?C0068:
001C 900000      R     MOV     DPTR,#ptrDelta
001F E0                MOVX    A,@DPTR
0020 75F006            MOV     B,#06H
0023 A4                MUL     AB
0024 FF                MOV     R7,A
0025         ?C0069:
0025         ?C0067:
0025 900000      R     MOV     DPTR,#numBytesToRequestFromOpticalFIFO
0028 EF                MOV     A,R7
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 655
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 54  

002A 900000      E     MOV     DPTR,#gMAX30101deviceAddress
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
002F 6076              JZ      ?C0070
                                           ; SOURCE LINE # 679
0031 E4                CLR     A
0032 900000      R     MOV     DPTR,#blockArr+05H
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 680
0036 EF                MOV     A,R7
0037 54FE              ANL     A,#0FEH
0039 FF                MOV     R7,A
003A 7B01              MOV     R3,#01H
003C 7A00        R     MOV     R2,#HIGH blockArr
003E 7900        R     MOV     R1,#LOW blockArr
0040 900000      E     MOV     DPTR,#?_i2c_read?BYTE+04H
0043 7402              MOV     A,#02H
0045 F0                MOVX    @DPTR,A
0046 A3                INC     DPTR
0047 14                DEC     A
0048 F0                MOVX    @DPTR,A
0049 120000      E     LCALL   _i2c_read
                                           ; SOURCE LINE # 682
004C 900000      R     MOV     DPTR,#blockArr+02H
004F E0                MOVX    A,@DPTR
0050 900000      R     MOV     DPTR,#MAX30101_InterruptStatus1_value
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 688
0054 900000      R     MOV     DPTR,#blockArr+05H
0057 7404              MOV     A,#04H
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 689
005A 900000      E     MOV     DPTR,#gMAX30101deviceAddress
005D E0                MOVX    A,@DPTR
005E 54FE              ANL     A,#0FEH
0060 FF                MOV     R7,A
0061 7B01              MOV     R3,#01H
0063 7A00        R     MOV     R2,#HIGH blockArr
0065 7900        R     MOV     R1,#LOW blockArr
0067 900000      E     MOV     DPTR,#?_i2c_read?BYTE+04H
006A 7403              MOV     A,#03H
006C F0                MOVX    @DPTR,A
006D A3                INC     DPTR
006E 7401              MOV     A,#01H
0070 F0                MOVX    @DPTR,A
0071 120000      E     LCALL   _i2c_read
                                           ; SOURCE LINE # 698
0074 900000      R     MOV     DPTR,#blockArr+04H
0077 E0                MOVX    A,@DPTR
0078 FF                MOV     R7,A
0079 900000      R     MOV     DPTR,#blockArr+02H
007C E0                MOVX    A,@DPTR
007D C3                CLR     C
007E 9F                SUBB    A,R7
007F 541F              ANL     A,#01FH
0081 900000      R     MOV     DPTR,#ptrDelta
0084 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 705
0085 900000      R     MOV     DPTR,#blockArr+05H
0088 7407              MOV     A,#07H
008A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 707
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 55  

008B 900000      E     MOV     DPTR,#gMAX30101deviceAddress
008E E0                MOVX    A,@DPTR
008F 54FE              ANL     A,#0FEH
0091 FF                MOV     R7,A
0092 7B01              MOV     R3,#01H
0094 7A00        R     MOV     R2,#HIGH blockArr
0096 7900        R     MOV     R1,#LOW blockArr
0098 900000      R     MOV     DPTR,#numBytesToRequestFromOpticalFIFO
009B E0                MOVX    A,@DPTR
009C 900000      E     MOV     DPTR,#?_i2c_read?BYTE+04H
009F F0                MOVX    @DPTR,A
00A0 A3                INC     DPTR
00A1 7401              MOV     A,#01H
00A3 F0                MOVX    @DPTR,A
00A4 120000      E     LCALL   _i2c_read
                                           ; SOURCE LINE # 712
00A7         ?C0070:
                                           ; SOURCE LINE # 747
00A7 900000      R     MOV     DPTR,#gMockHIDFIFOChannels
00AA E0                MOVX    A,@DPTR
00AB D3                SETB    C
00AC 9400              SUBB    A,#00H
00AE 5003              JNC     $ + 5H
00B0 020000      R     LJMP    ?C0071
                                           ; SOURCE LINE # 761
00B3 E4                CLR     A
00B4 900000      R     MOV     DPTR,#gMockHIDFIFOChannel
00B7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 763
00B8 900000      R     MOV     DPTR,#inner
00BB F0                MOVX    @DPTR,A
00BC         ?C0072:
00BC 900000      R     MOV     DPTR,#numBytesToRequestFromOpticalFIFO
00BF E0                MOVX    A,@DPTR
00C0 FF                MOV     R7,A
00C1 900000      R     MOV     DPTR,#inner
00C4 E0                MOVX    A,@DPTR
00C5 FD                MOV     R5,A
00C6 C3                CLR     C
00C7 9F                SUBB    A,R7
00C8 4003              JC      $ + 5H
00CA 020000      R     LJMP    ?C0071
                                           ; SOURCE LINE # 764
00CD 900000      R     MOV     DPTR,#gMockHIDFIFOChannel
00D0 E0                MOVX    A,@DPTR
00D1 14                DEC     A
00D2 604D              JZ      ?C0077
00D4 14                DEC     A
00D5 7003              JNZ     $ + 5H
00D7 020000      R     LJMP    ?C0078
00DA 14                DEC     A
00DB 7003              JNZ     $ + 5H
00DD 020000      R     LJMP    ?C0079
00E0 2403              ADD     A,#03H
00E2 6003              JZ      $ + 5H
00E4 020000      R     LJMP    ?C0075
                                           ; SOURCE LINE # 765
00E7         ?C0076:
                                           ; SOURCE LINE # 766
00E7 900000      R     MOV     DPTR,#gMockHIDFIFOCh1+01H
00EA E0                MOVX    A,@DPTR
00EB 04                INC     A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 56  

00EC F0                MOVX    @DPTR,A
00ED 7006              JNZ     ?C0151
00EF 900000      R     MOV     DPTR,#gMockHIDFIFOCh1
00F2 E0                MOVX    A,@DPTR
00F3 04                INC     A
00F4 F0                MOVX    @DPTR,A
00F5         ?C0151:
                                           ; SOURCE LINE # 767
00F5 900000      R     MOV     DPTR,#inner
00F8 E0                MOVX    A,@DPTR
00F9 FC                MOV     R4,A
00FA 2400        R     ADD     A,#LOW blockArr+02H
00FC F582              MOV     DPL,A
00FE E4                CLR     A
00FF 3400        R     ADDC    A,#HIGH blockArr+02H
0101 F583              MOV     DPH,A
0103 E4                CLR     A
0104 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 768
0105 900000      R     MOV     DPTR,#gMockHIDFIFOCh1
0108 E0                MOVX    A,@DPTR
0109 FA                MOV     R2,A
010A A3                INC     DPTR
010B E0                MOVX    A,@DPTR
010C FB                MOV     R3,A
010D EA                MOV     A,R2
010E FF                MOV     R7,A
010F 7400        R     MOV     A,#LOW blockArr+03H
0111 2C                ADD     A,R4
0112 F582              MOV     DPL,A
0114 E4                CLR     A
0115 3400        R     ADDC    A,#HIGH blockArr+03H
0117 F583              MOV     DPH,A
0119 EF                MOV     A,R7
011A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 769
011B 7400        R     MOV     A,#LOW blockArr+04H
011D 2D                ADD     A,R5
                                           ; SOURCE LINE # 770
011E 020000      R     LJMP    ?C0174
                                           ; SOURCE LINE # 771
0121         ?C0077:
                                           ; SOURCE LINE # 772
0121 900000      R     MOV     DPTR,#gMockHIDFIFOCh2+01H
0124 E0                MOVX    A,@DPTR
0125 04                INC     A
0126 F0                MOVX    @DPTR,A
0127 7006              JNZ     ?C0152
0129 900000      R     MOV     DPTR,#gMockHIDFIFOCh2
012C E0                MOVX    A,@DPTR
012D 04                INC     A
012E F0                MOVX    @DPTR,A
012F         ?C0152:
                                           ; SOURCE LINE # 773
012F 900000      R     MOV     DPTR,#inner
0132 E0                MOVX    A,@DPTR
0133 FD                MOV     R5,A
0134 2400        R     ADD     A,#LOW blockArr+02H
0136 F582              MOV     DPL,A
0138 E4                CLR     A
0139 3400        R     ADDC    A,#HIGH blockArr+02H
013B F583              MOV     DPH,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 57  

013D E4                CLR     A
013E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 774
013F 900000      R     MOV     DPTR,#gMockHIDFIFOCh2
0142 E0                MOVX    A,@DPTR
0143 FA                MOV     R2,A
0144 A3                INC     DPTR
0145 E0                MOVX    A,@DPTR
0146 FB                MOV     R3,A
0147 EA                MOV     A,R2
0148 FF                MOV     R7,A
0149 7400        R     MOV     A,#LOW blockArr+03H
014B 2D                ADD     A,R5
014C F582              MOV     DPL,A
014E E4                CLR     A
014F 3400        R     ADDC    A,#HIGH blockArr+03H
0151 F583              MOV     DPH,A
0153 EF                MOV     A,R7
0154 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 775
0155 900000      R     MOV     DPTR,#inner
0158 E0                MOVX    A,@DPTR
0159 2400        R     ADD     A,#LOW blockArr+04H
015B         ?C0172:
                                           ; SOURCE LINE # 776
015B 8076              SJMP    ?C0174
                                           ; SOURCE LINE # 777
015D         ?C0078:
                                           ; SOURCE LINE # 778
015D 900000      R     MOV     DPTR,#gMockHIDFIFOCh3+01H
0160 E0                MOVX    A,@DPTR
0161 04                INC     A
0162 F0                MOVX    @DPTR,A
0163 7006              JNZ     ?C0153
0165 900000      R     MOV     DPTR,#gMockHIDFIFOCh3
0168 E0                MOVX    A,@DPTR
0169 04                INC     A
016A F0                MOVX    @DPTR,A
016B         ?C0153:
                                           ; SOURCE LINE # 779
016B 900000      R     MOV     DPTR,#inner
016E E0                MOVX    A,@DPTR
016F FD                MOV     R5,A
0170 2400        R     ADD     A,#LOW blockArr+02H
0172 F582              MOV     DPL,A
0174 E4                CLR     A
0175 3400        R     ADDC    A,#HIGH blockArr+02H
0177 F583              MOV     DPH,A
0179 E4                CLR     A
017A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 780
017B 900000      R     MOV     DPTR,#gMockHIDFIFOCh3
017E E0                MOVX    A,@DPTR
017F FA                MOV     R2,A
0180 A3                INC     DPTR
0181 E0                MOVX    A,@DPTR
0182 FB                MOV     R3,A
0183 EA                MOV     A,R2
0184 FF                MOV     R7,A
0185 7400        R     MOV     A,#LOW blockArr+03H
0187 2D                ADD     A,R5
0188 F582              MOV     DPL,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 58  

018A E4                CLR     A
018B 3400        R     ADDC    A,#HIGH blockArr+03H
018D F583              MOV     DPH,A
018F EF                MOV     A,R7
0190 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 781
0191 900000      R     MOV     DPTR,#inner
0194 E0                MOVX    A,@DPTR
0195 2400        R     ADD     A,#LOW blockArr+04H
0197         ?C0173:
                                           ; SOURCE LINE # 782
0197 803A              SJMP    ?C0174
                                           ; SOURCE LINE # 783
0199         ?C0079:
                                           ; SOURCE LINE # 784
0199 900000      R     MOV     DPTR,#gMockHIDFIFOCh4+01H
019C E0                MOVX    A,@DPTR
019D 04                INC     A
019E F0                MOVX    @DPTR,A
019F 7006              JNZ     ?C0154
01A1 900000      R     MOV     DPTR,#gMockHIDFIFOCh4
01A4 E0                MOVX    A,@DPTR
01A5 04                INC     A
01A6 F0                MOVX    @DPTR,A
01A7         ?C0154:
                                           ; SOURCE LINE # 785
01A7 900000      R     MOV     DPTR,#inner
01AA E0                MOVX    A,@DPTR
01AB FD                MOV     R5,A
01AC 2400        R     ADD     A,#LOW blockArr+02H
01AE F582              MOV     DPL,A
01B0 E4                CLR     A
01B1 3400        R     ADDC    A,#HIGH blockArr+02H
01B3 F583              MOV     DPH,A
01B5 E4                CLR     A
01B6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 786
01B7 900000      R     MOV     DPTR,#gMockHIDFIFOCh4
01BA E0                MOVX    A,@DPTR
01BB FA                MOV     R2,A
01BC A3                INC     DPTR
01BD E0                MOVX    A,@DPTR
01BE FB                MOV     R3,A
01BF EA                MOV     A,R2
01C0 FF                MOV     R7,A
01C1 7400        R     MOV     A,#LOW blockArr+03H
01C3 2D                ADD     A,R5
01C4 F582              MOV     DPL,A
01C6 E4                CLR     A
01C7 3400        R     ADDC    A,#HIGH blockArr+03H
01C9 F583              MOV     DPH,A
01CB EF                MOV     A,R7
01CC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 787
01CD 900000      R     MOV     DPTR,#inner
01D0 E0                MOVX    A,@DPTR
01D1 2400        R     ADD     A,#LOW blockArr+04H
01D3         ?C0174:
01D3 F582              MOV     DPL,A
01D5 E4                CLR     A
01D6 3400        R     ADDC    A,#HIGH blockArr+04H
01D8 F583              MOV     DPH,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 59  

01DA EB                MOV     A,R3
01DB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 788
                                           ; SOURCE LINE # 789
01DC         ?C0075:
                                           ; SOURCE LINE # 791
01DC 900000      R     MOV     DPTR,#gMockHIDFIFOChannel
01DF E0                MOVX    A,@DPTR
01E0 04                INC     A
01E1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 792
01E2 900000      R     MOV     DPTR,#gMockHIDFIFOChannels
01E5 E0                MOVX    A,@DPTR
01E6 FF                MOV     R7,A
01E7 900000      R     MOV     DPTR,#gMockHIDFIFOChannel
01EA E0                MOVX    A,@DPTR
01EB C3                CLR     C
01EC 9F                SUBB    A,R7
01ED 4002              JC      ?C0074
                                           ; SOURCE LINE # 793
01EF E4                CLR     A
01F0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 794
                                           ; SOURCE LINE # 795
01F1         ?C0074:
01F1 900000      R     MOV     DPTR,#inner
01F4 E0                MOVX    A,@DPTR
01F5 2403              ADD     A,#03H
01F7 F0                MOVX    @DPTR,A
01F8 020000      R     LJMP    ?C0072
                                           ; SOURCE LINE # 796
01FB         ?C0071:
                                           ; SOURCE LINE # 801
01FB 900000      E     MOV     DPTR,#gMAX30101deviceAddress
01FE E0                MOVX    A,@DPTR
01FF FF                MOV     R7,A
0200 700C              JNZ     ?C0081
                                           ; SOURCE LINE # 802
                                           ; SOURCE LINE # 803
0202 900000      R     MOV     DPTR,#ptrDelta
0205 741A              MOV     A,#01AH
0207 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 804
0208 900000      R     MOV     DPTR,#gMockHIDFIFOChannels
020B 7403              MOV     A,#03H
020D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 805
020E         ?C0081:
                                           ; SOURCE LINE # 806
020E EF                MOV     A,R7
020F 700C              JNZ     ?C0083
0211 900000      R     MOV     DPTR,#gMockHIDFIFOChannels
0214 E0                MOVX    A,@DPTR
0215 D3                SETB    C
0216 9400              SUBB    A,#00H
0218 5003              JNC     $ + 5H
021A 020000      R     LJMP    ?C0099
021D         ?C0083:
                                           ; SOURCE LINE # 811
                                           ; SOURCE LINE # 814
021D 900000      R     MOV     DPTR,#IO_BUFFER+01H
0220 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 60  

0221 FB                MOV     R3,A
0222 A3                INC     DPTR
0223 E0                MOVX    A,@DPTR
0224 FA                MOV     R2,A
0225 A3                INC     DPTR
0226 E0                MOVX    A,@DPTR
0227 F9                MOV     R1,A
0228 7401              MOV     A,#01H
022A 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 815
022D 900000      R     MOV     DPTR,#gOS21numIntServiced
0230 E0                MOVX    A,@DPTR
0231 FF                MOV     R7,A
0232 04                INC     A
0233 F0                MOVX    @DPTR,A
0234 900000      R     MOV     DPTR,#IO_BUFFER+01H
0237 E0                MOVX    A,@DPTR
0238 FB                MOV     R3,A
0239 A3                INC     DPTR
023A E0                MOVX    A,@DPTR
023B FA                MOV     R2,A
023C A3                INC     DPTR
023D E0                MOVX    A,@DPTR
023E F9                MOV     R1,A
023F 900001            MOV     DPTR,#01H
0242 EF                MOV     A,R7
0243 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 816
0246 900000      R     MOV     DPTR,#ptrDelta
0249 E0                MOVX    A,@DPTR
024A 900002            MOV     DPTR,#02H
024D 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 818
0250 900000      R     MOV     DPTR,#MAX30101_InterruptStatus1_value
0253 E0                MOVX    A,@DPTR
0254 900003            MOV     DPTR,#03H
0257 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 819
025A E4                CLR     A
025B 900000      R     MOV     DPTR,#inner
025E F0                MOVX    @DPTR,A
025F         ?C0084:
025F 300004      R     JNB     singleSample,?C0087
0262 7F06              MOV     R7,#06H
0264 8002              SJMP    ?C0088
0266         ?C0087:
0266 7F3C              MOV     R7,#03CH
0268         ?C0088:
0268 900000      R     MOV     DPTR,#inner
026B E0                MOVX    A,@DPTR
026C FE                MOV     R6,A
026D C3                CLR     C
026E 9F                SUBB    A,R7
026F 502E              JNC     ?C0085
                                           ; SOURCE LINE # 820
0271 7400        R     MOV     A,#LOW blockArr+02H
0273 2E                ADD     A,R6
0274 F582              MOV     DPL,A
0276 E4                CLR     A
0277 3400        R     ADDC    A,#HIGH blockArr+02H
0279 F583              MOV     DPH,A
027B E0                MOVX    A,@DPTR
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 61  

027C FF                MOV     R7,A
027D EE                MOV     A,R6
027E 2404              ADD     A,#04H
0280 FD                MOV     R5,A
0281 E4                CLR     A
0282 33                RLC     A
0283 FC                MOV     R4,A
0284 900000      R     MOV     DPTR,#IO_BUFFER+01H
0287 E0                MOVX    A,@DPTR
0288 FB                MOV     R3,A
0289 A3                INC     DPTR
028A E0                MOVX    A,@DPTR
028B FA                MOV     R2,A
028C A3                INC     DPTR
028D E0                MOVX    A,@DPTR
028E F9                MOV     R1,A
028F 8D82              MOV     DPL,R5
0291 8C83              MOV     DPH,R4
0293 EF                MOV     A,R7
0294 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 821
0297 900000      R     MOV     DPTR,#inner
029A E0                MOVX    A,@DPTR
029B 04                INC     A
029C F0                MOVX    @DPTR,A
029D 80C0              SJMP    ?C0084
029F         ?C0085:
                                           ; SOURCE LINE # 824
029F 120000      E     LCALL   SendPacketWaitEP1INready
                                           ; SOURCE LINE # 828
02A2 300003      R     JNB     singleReport,$ + 6H
02A5 020000      R     LJMP    ?C0099
                                           ; SOURCE LINE # 829
                                           ; SOURCE LINE # 830
02A8 900000      R     MOV     DPTR,#ptrDelta
02AB E0                MOVX    A,@DPTR
02AC 7003              JNZ     ?C0090
                                           ; SOURCE LINE # 831
02AE 7420              MOV     A,#020H
02B0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 832
02B1         ?C0090:
                                           ; SOURCE LINE # 833
02B1 E4                CLR     A
02B2 900000      R     MOV     DPTR,#outer
02B5 F0                MOVX    @DPTR,A
02B6         ?C0091:
02B6 900000      R     MOV     DPTR,#ptrDelta
02B9 E0                MOVX    A,@DPTR
02BA FF                MOV     R7,A
02BB 75F00A            MOV     B,#0AH
02BE 84                DIV     AB
02BF FE                MOV     R6,A
02C0 900000      R     MOV     DPTR,#outer
02C3 E0                MOVX    A,@DPTR
02C4 FD                MOV     R5,A
02C5 C3                CLR     C
02C6 9E                SUBB    A,R6
02C7 5079              JNC     ?C0099
                                           ; SOURCE LINE # 834
                                           ; SOURCE LINE # 835
02C9 ED                MOV     A,R5
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 62  

02CA 04                INC     A
02CB 75F03C            MOV     B,#03CH
02CE A4                MUL     AB
02CF FE                MOV     R6,A
02D0 EF                MOV     A,R7
02D1 75F006            MOV     B,#06H
02D4 A4                MUL     AB
02D5 C3                CLR     C
02D6 9E                SUBB    A,R6
02D7 900000      R     MOV     DPTR,#bytesRemaining
02DA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 836
02DB E4                CLR     A
02DC 900000      R     MOV     DPTR,#inner
02DF F0                MOVX    @DPTR,A
02E0         ?C0094:
02E0 900000      R     MOV     DPTR,#bytesRemaining
02E3 E0                MOVX    A,@DPTR
02E4 FF                MOV     R7,A
02E5 D3                SETB    C
02E6 943C              SUBB    A,#03CH
02E8 5002              JNC     ?C0097
02EA 8002              SJMP    ?C0098
02EC         ?C0097:
02EC 7F3C              MOV     R7,#03CH
02EE         ?C0098:
02EE 900000      R     MOV     DPTR,#inner
02F1 E0                MOVX    A,@DPTR
02F2 C3                CLR     C
02F3 9F                SUBB    A,R7
02F4 5040              JNC     ?C0095
                                           ; SOURCE LINE # 837
02F6 E0                MOVX    A,@DPTR
02F7 FF                MOV     R7,A
02F8 A3                INC     DPTR
02F9 E0                MOVX    A,@DPTR
02FA 75F03C            MOV     B,#03CH
02FD A4                MUL     AB
02FE 2F                ADD     A,R7
02FF F582              MOV     DPL,A
0301 E4                CLR     A
0302 35F0              ADDC    A,B
0304 F583              MOV     DPH,A
0306 E582              MOV     A,DPL
0308 2400        R     ADD     A,#LOW blockArr+03EH
030A F582              MOV     DPL,A
030C E583              MOV     A,DPH
030E 3400        R     ADDC    A,#HIGH blockArr+03EH
0310 F583              MOV     DPH,A
0312 E0                MOVX    A,@DPTR
0313 FE                MOV     R6,A
0314 EF                MOV     A,R7
0315 2404              ADD     A,#04H
0317 FD                MOV     R5,A
0318 E4                CLR     A
0319 33                RLC     A
031A FC                MOV     R4,A
031B 900000      R     MOV     DPTR,#IO_BUFFER+01H
031E E0                MOVX    A,@DPTR
031F FB                MOV     R3,A
0320 A3                INC     DPTR
0321 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 63  

0322 FA                MOV     R2,A
0323 A3                INC     DPTR
0324 E0                MOVX    A,@DPTR
0325 F9                MOV     R1,A
0326 8D82              MOV     DPL,R5
0328 8C83              MOV     DPH,R4
032A EE                MOV     A,R6
032B 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 838
032E 900000      R     MOV     DPTR,#inner
0331 E0                MOVX    A,@DPTR
0332 04                INC     A
0333 F0                MOVX    @DPTR,A
0334 80AA              SJMP    ?C0094
0336         ?C0095:
                                           ; SOURCE LINE # 841
0336 120000      E     LCALL   SendPacketWaitEP1INready
                                           ; SOURCE LINE # 845
0339 900000      R     MOV     DPTR,#outer
033C E0                MOVX    A,@DPTR
033D 04                INC     A
033E F0                MOVX    @DPTR,A
033F 020000      R     LJMP    ?C0091
                                           ; SOURCE LINE # 846
                                           ; SOURCE LINE # 847
                                           ; SOURCE LINE # 1034
0342         ?C0099:
0342 22                RET     
             ; FUNCTION readOS21 (END)

             ; FUNCTION readLIS2DH (BEGIN)
                                           ; SOURCE LINE # 1047
                                           ; SOURCE LINE # 1048
                                           ; SOURCE LINE # 1058
0000 C200        R     CLR     singleSample
                                           ; SOURCE LINE # 1059
0002 D200        R     SETB    singleReport
                                           ; SOURCE LINE # 1076
0004 E4                CLR     A
0005 900000      R     MOV     DPTR,#lis2dh_STATUS_REG2_value
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1090
0009 300002      R     JNB     singleSample,?C0100
                                           ; SOURCE LINE # 1091
000C D200        R     SETB    singleReport
                                           ; SOURCE LINE # 1092
000E         ?C0100:
                                           ; SOURCE LINE # 1095
000E 900000      E     MOV     DPTR,#gMAX30101_ModeConfiguration_value
0011 E0                MOVX    A,@DPTR
0012 B40202            CJNE    A,#02H,?C0102
                                           ; SOURCE LINE # 1097
0015 C200        R     CLR     singleReport
                                           ; SOURCE LINE # 1098
                                           ; SOURCE LINE # 1101
0017         ?C0102:
                                           ; SOURCE LINE # 1102
0017 E4                CLR     A
0018 900000      R     MOV     DPTR,#gLIS2DHready
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1111
001C 900000      E     MOV     DPTR,#gLIS2DHdeviceAddress
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 64  

001F E0                MOVX    A,@DPTR
0020 6038              JZ      ?C0103
                                           ; SOURCE LINE # 1116
0022 7B01              MOV     R3,#01H
0024 7A00        R     MOV     R2,#HIGH lis2dh_FIFO_SRC_REG_value
0026 7900        R     MOV     R1,#LOW lis2dh_FIFO_SRC_REG_value
0028 7F2F              MOV     R7,#02FH
002A 120000      E     LCALL   _lis2dh_RegRead
                                           ; SOURCE LINE # 1118
002D 900000      R     MOV     DPTR,#lis2dh_FIFO_SRC_REG_value
0030 E0                MOVX    A,@DPTR
0031 900000      R     MOV     DPTR,#ptrDelta
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1119
0035 30E602            JNB     ACC.6,?C0104
                                           ; SOURCE LINE # 1124
0038 D2A2              SETB    Led1
                                           ; SOURCE LINE # 1127
003A         ?C0104:
                                           ; SOURCE LINE # 1139
003A 900000      R     MOV     DPTR,#blockArr+05H
003D 74A8              MOV     A,#0A8H
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1149
0040 900000      E     MOV     DPTR,#gLIS2DHdeviceAddress
0043 E0                MOVX    A,@DPTR
0044 54FE              ANL     A,#0FEH
0046 FF                MOV     R7,A
0047 7B01              MOV     R3,#01H
0049 7A00        R     MOV     R2,#HIGH blockArr
004B 7900        R     MOV     R1,#LOW blockArr
004D 900000      E     MOV     DPTR,#?_i2c_read?BYTE+04H
0050 743C              MOV     A,#03CH
0052 F0                MOVX    @DPTR,A
0053 A3                INC     DPTR
0054 7401              MOV     A,#01H
0056 F0                MOVX    @DPTR,A
0057 120000      E     LCALL   _i2c_read
                                           ; SOURCE LINE # 1189
005A         ?C0103:
                                           ; SOURCE LINE # 1191
005A 900000      R     MOV     DPTR,#gMockHIDreport2
005D E0                MOVX    A,@DPTR
005E D3                SETB    C
005F 9400              SUBB    A,#00H
0061 5003              JNC     $ + 5H
0063 020000      R     LJMP    ?C0105
                                           ; SOURCE LINE # 1197
0066 E4                CLR     A
0067 900000      R     MOV     DPTR,#gMockHIDFIFOChannel
006A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1200
006B 900000      R     MOV     DPTR,#inner
006E F0                MOVX    @DPTR,A
006F         ?C0106:
006F 300004      R     JNB     singleSample,?C0109
0072 7F06              MOV     R7,#06H
0074 8010              SJMP    ?C0110
0076         ?C0109:
0076 300004      R     JNB     singleReport,?C0111
0079 7F3C              MOV     R7,#03CH
007B 8009              SJMP    ?C0112
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 65  

007D         ?C0111:
007D 900000      R     MOV     DPTR,#ptrDelta
0080 E0                MOVX    A,@DPTR
0081 75F006            MOV     B,#06H
0084 A4                MUL     AB
0085 FF                MOV     R7,A
0086         ?C0112:
0086         ?C0110:
0086 900000      R     MOV     DPTR,#inner
0089 E0                MOVX    A,@DPTR
008A C3                CLR     C
008B 9F                SUBB    A,R7
008C 4003              JC      $ + 5H
008E 020000      R     LJMP    ?C0105
                                           ; SOURCE LINE # 1201
0091 900000      R     MOV     DPTR,#gMockHIDFIFOChannel
0094 E0                MOVX    A,@DPTR
0095 14                DEC     A
0096 601A              JZ      ?C0115
0098 14                DEC     A
0099 602A              JZ      ?C0116
009B 2402              ADD     A,#02H
009D 705A              JNZ     ?C0113
                                           ; SOURCE LINE # 1202
009F         ?C0114:
                                           ; SOURCE LINE # 1203
009F 900000      R     MOV     DPTR,#gMockHID2X+01H
00A2 E0                MOVX    A,@DPTR
00A3 04                INC     A
00A4 F0                MOVX    @DPTR,A
00A5 7006              JNZ     ?C0155
00A7 900000      R     MOV     DPTR,#gMockHID2X
00AA E0                MOVX    A,@DPTR
00AB 04                INC     A
00AC F0                MOVX    @DPTR,A
00AD         ?C0155:
                                           ; SOURCE LINE # 1204
00AD 900000      R     MOV     DPTR,#gMockHID2X
                                           ; SOURCE LINE # 1205
                                           ; SOURCE LINE # 1206
00B0 8024              SJMP    ?C0176
                                           ; SOURCE LINE # 1207
00B2         ?C0115:
                                           ; SOURCE LINE # 1208
00B2 900000      R     MOV     DPTR,#gMockHID2Y+01H
00B5 E0                MOVX    A,@DPTR
00B6 04                INC     A
00B7 F0                MOVX    @DPTR,A
00B8 7006              JNZ     ?C0156
00BA 900000      R     MOV     DPTR,#gMockHID2Y
00BD E0                MOVX    A,@DPTR
00BE 04                INC     A
00BF F0                MOVX    @DPTR,A
00C0         ?C0156:
                                           ; SOURCE LINE # 1209
00C0 900000      R     MOV     DPTR,#gMockHID2Y
00C3         ?C0175:
                                           ; SOURCE LINE # 1210
                                           ; SOURCE LINE # 1211
00C3 8011              SJMP    ?C0176
                                           ; SOURCE LINE # 1212
00C5         ?C0116:
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 66  

                                           ; SOURCE LINE # 1213
00C5 900000      R     MOV     DPTR,#gMockHID2Z+01H
00C8 E0                MOVX    A,@DPTR
00C9 04                INC     A
00CA F0                MOVX    @DPTR,A
00CB 7006              JNZ     ?C0157
00CD 900000      R     MOV     DPTR,#gMockHID2Z
00D0 E0                MOVX    A,@DPTR
00D1 04                INC     A
00D2 F0                MOVX    @DPTR,A
00D3         ?C0157:
                                           ; SOURCE LINE # 1214
00D3 900000      R     MOV     DPTR,#gMockHID2Z
00D6         ?C0176:
00D6 E0                MOVX    A,@DPTR
00D7 FC                MOV     R4,A
00D8 A3                INC     DPTR
00D9 E0                MOVX    A,@DPTR
00DA FD                MOV     R5,A
00DB EC                MOV     A,R4
00DC FF                MOV     R7,A
00DD 900000      R     MOV     DPTR,#inner
00E0 E0                MOVX    A,@DPTR
00E1 FE                MOV     R6,A
00E2 2400        R     ADD     A,#LOW blockArr+02H
00E4 F582              MOV     DPL,A
00E6 E4                CLR     A
00E7 3400        R     ADDC    A,#HIGH blockArr+02H
00E9 F583              MOV     DPH,A
00EB EF                MOV     A,R7
00EC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1215
00ED 7400        R     MOV     A,#LOW blockArr+03H
00EF 2E                ADD     A,R6
00F0 F582              MOV     DPL,A
00F2 E4                CLR     A
00F3 3400        R     ADDC    A,#HIGH blockArr+03H
00F5 F583              MOV     DPH,A
00F7 ED                MOV     A,R5
00F8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1216
                                           ; SOURCE LINE # 1217
00F9         ?C0113:
                                           ; SOURCE LINE # 1218
00F9 900000      R     MOV     DPTR,#gMockHIDFIFOChannel
00FC E0                MOVX    A,@DPTR
00FD 04                INC     A
00FE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1219
00FF E0                MOVX    A,@DPTR
0100 C3                CLR     C
0101 9403              SUBB    A,#03H
0103 4002              JC      ?C0108
                                           ; SOURCE LINE # 1220
0105 E4                CLR     A
0106 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1221
                                           ; SOURCE LINE # 1222
0107         ?C0108:
0107 900000      R     MOV     DPTR,#inner
010A E0                MOVX    A,@DPTR
010B 2402              ADD     A,#02H
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 67  

010D F0                MOVX    @DPTR,A
010E 020000      R     LJMP    ?C0106
                                           ; SOURCE LINE # 1223
0111         ?C0105:
                                           ; SOURCE LINE # 1226
0111 900000      E     MOV     DPTR,#gLIS2DHdeviceAddress
0114 E0                MOVX    A,@DPTR
0115 7003              JNZ     $ + 5H
0117 020000      R     LJMP    ?C0135
                                           ; SOURCE LINE # 1231
011A 900000      R     MOV     DPTR,#IO_BUFFER+01H
011D E0                MOVX    A,@DPTR
011E FB                MOV     R3,A
011F A3                INC     DPTR
0120 E0                MOVX    A,@DPTR
0121 FA                MOV     R2,A
0122 A3                INC     DPTR
0123 E0                MOVX    A,@DPTR
0124 F9                MOV     R1,A
0125 7402              MOV     A,#02H
0127 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 1232
012A 900000      R     MOV     DPTR,#gLIS2DHnumIntServiced
012D E0                MOVX    A,@DPTR
012E FF                MOV     R7,A
012F 04                INC     A
0130 F0                MOVX    @DPTR,A
0131 900000      R     MOV     DPTR,#IO_BUFFER+01H
0134 E0                MOVX    A,@DPTR
0135 FB                MOV     R3,A
0136 A3                INC     DPTR
0137 E0                MOVX    A,@DPTR
0138 FA                MOV     R2,A
0139 A3                INC     DPTR
013A E0                MOVX    A,@DPTR
013B F9                MOV     R1,A
013C 900001            MOV     DPTR,#01H
013F EF                MOV     A,R7
0140 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 1233
0143 900000      R     MOV     DPTR,#lis2dh_FIFO_SRC_REG_value
0146 E0                MOVX    A,@DPTR
0147 900002            MOV     DPTR,#02H
014A 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 1234
014D 900003            MOV     DPTR,#03H
0150 7432              MOV     A,#032H
0152 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 1235
0155 E4                CLR     A
0156 900000      R     MOV     DPTR,#inner
0159 F0                MOVX    @DPTR,A
015A         ?C0119:
015A 300004      R     JNB     singleSample,?C0122
015D 7F06              MOV     R7,#06H
015F 8002              SJMP    ?C0123
0161         ?C0122:
0161 7F3C              MOV     R7,#03CH
0163         ?C0123:
0163 900000      R     MOV     DPTR,#inner
0166 E0                MOVX    A,@DPTR
0167 FE                MOV     R6,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 68  

0168 C3                CLR     C
0169 9F                SUBB    A,R7
016A 502E              JNC     ?C0120
                                           ; SOURCE LINE # 1236
016C 7400        R     MOV     A,#LOW blockArr+02H
016E 2E                ADD     A,R6
016F F582              MOV     DPL,A
0171 E4                CLR     A
0172 3400        R     ADDC    A,#HIGH blockArr+02H
0174 F583              MOV     DPH,A
0176 E0                MOVX    A,@DPTR
0177 FF                MOV     R7,A
0178 EE                MOV     A,R6
0179 2404              ADD     A,#04H
017B FD                MOV     R5,A
017C E4                CLR     A
017D 33                RLC     A
017E FC                MOV     R4,A
017F 900000      R     MOV     DPTR,#IO_BUFFER+01H
0182 E0                MOVX    A,@DPTR
0183 FB                MOV     R3,A
0184 A3                INC     DPTR
0185 E0                MOVX    A,@DPTR
0186 FA                MOV     R2,A
0187 A3                INC     DPTR
0188 E0                MOVX    A,@DPTR
0189 F9                MOV     R1,A
018A 8D82              MOV     DPL,R5
018C 8C83              MOV     DPH,R4
018E EF                MOV     A,R7
018F 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 1237
0192 900000      R     MOV     DPTR,#inner
0195 E0                MOVX    A,@DPTR
0196 04                INC     A
0197 F0                MOVX    @DPTR,A
0198 80C0              SJMP    ?C0119
019A         ?C0120:
                                           ; SOURCE LINE # 1240
019A 120000      E     LCALL   SendPacketWaitEP1INready
                                           ; SOURCE LINE # 1244
019D 300003      R     JNB     singleReport,$ + 6H
01A0 020000      R     LJMP    ?C0124
                                           ; SOURCE LINE # 1245
                                           ; SOURCE LINE # 1246
01A3 900000      R     MOV     DPTR,#ptrDelta
01A6 E0                MOVX    A,@DPTR
01A7 7003              JNZ     ?C0125
                                           ; SOURCE LINE # 1247
01A9 7420              MOV     A,#020H
01AB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1248
01AC         ?C0125:
                                           ; SOURCE LINE # 1249
01AC E4                CLR     A
01AD 900000      R     MOV     DPTR,#outer
01B0 F0                MOVX    @DPTR,A
01B1         ?C0126:
01B1 900000      R     MOV     DPTR,#ptrDelta
01B4 E0                MOVX    A,@DPTR
01B5 FF                MOV     R7,A
01B6 75F00A            MOV     B,#0AH
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 69  

01B9 84                DIV     AB
01BA FE                MOV     R6,A
01BB 900000      R     MOV     DPTR,#outer
01BE E0                MOVX    A,@DPTR
01BF FD                MOV     R5,A
01C0 C3                CLR     C
01C1 9E                SUBB    A,R6
01C2 5079              JNC     ?C0124
                                           ; SOURCE LINE # 1250
                                           ; SOURCE LINE # 1251
01C4 ED                MOV     A,R5
01C5 04                INC     A
01C6 75F03C            MOV     B,#03CH
01C9 A4                MUL     AB
01CA FE                MOV     R6,A
01CB EF                MOV     A,R7
01CC 75F006            MOV     B,#06H
01CF A4                MUL     AB
01D0 C3                CLR     C
01D1 9E                SUBB    A,R6
01D2 900000      R     MOV     DPTR,#bytesRemaining
01D5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1252
01D6 E4                CLR     A
01D7 900000      R     MOV     DPTR,#inner
01DA F0                MOVX    @DPTR,A
01DB         ?C0129:
01DB 900000      R     MOV     DPTR,#bytesRemaining
01DE E0                MOVX    A,@DPTR
01DF FF                MOV     R7,A
01E0 D3                SETB    C
01E1 943C              SUBB    A,#03CH
01E3 5002              JNC     ?C0132
01E5 8002              SJMP    ?C0133
01E7         ?C0132:
01E7 7F3C              MOV     R7,#03CH
01E9         ?C0133:
01E9 900000      R     MOV     DPTR,#inner
01EC E0                MOVX    A,@DPTR
01ED C3                CLR     C
01EE 9F                SUBB    A,R7
01EF 5040              JNC     ?C0130
                                           ; SOURCE LINE # 1253
01F1 E0                MOVX    A,@DPTR
01F2 FF                MOV     R7,A
01F3 A3                INC     DPTR
01F4 E0                MOVX    A,@DPTR
01F5 75F03C            MOV     B,#03CH
01F8 A4                MUL     AB
01F9 2F                ADD     A,R7
01FA F582              MOV     DPL,A
01FC E4                CLR     A
01FD 35F0              ADDC    A,B
01FF F583              MOV     DPH,A
0201 E582              MOV     A,DPL
0203 2400        R     ADD     A,#LOW blockArr+03EH
0205 F582              MOV     DPL,A
0207 E583              MOV     A,DPH
0209 3400        R     ADDC    A,#HIGH blockArr+03EH
020B F583              MOV     DPH,A
020D E0                MOVX    A,@DPTR
020E FE                MOV     R6,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 70  

020F EF                MOV     A,R7
0210 2404              ADD     A,#04H
0212 FD                MOV     R5,A
0213 E4                CLR     A
0214 33                RLC     A
0215 FC                MOV     R4,A
0216 900000      R     MOV     DPTR,#IO_BUFFER+01H
0219 E0                MOVX    A,@DPTR
021A FB                MOV     R3,A
021B A3                INC     DPTR
021C E0                MOVX    A,@DPTR
021D FA                MOV     R2,A
021E A3                INC     DPTR
021F E0                MOVX    A,@DPTR
0220 F9                MOV     R1,A
0221 8D82              MOV     DPL,R5
0223 8C83              MOV     DPH,R4
0225 EE                MOV     A,R6
0226 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 1254
0229 900000      R     MOV     DPTR,#inner
022C E0                MOVX    A,@DPTR
022D 04                INC     A
022E F0                MOVX    @DPTR,A
022F 80AA              SJMP    ?C0129
0231         ?C0130:
                                           ; SOURCE LINE # 1257
0231 120000      E     LCALL   SendPacketWaitEP1INready
                                           ; SOURCE LINE # 1261
0234 900000      R     MOV     DPTR,#outer
0237 E0                MOVX    A,@DPTR
0238 04                INC     A
0239 F0                MOVX    @DPTR,A
023A 020000      R     LJMP    ?C0126
                                           ; SOURCE LINE # 1262
023D         ?C0124:
                                           ; SOURCE LINE # 1267
023D 7B01              MOV     R3,#01H
023F 7A00        R     MOV     R2,#HIGH lis2dh_FIFO_SRC_REG_value
0241 7900        R     MOV     R1,#LOW lis2dh_FIFO_SRC_REG_value
0243 7F2F              MOV     R7,#02FH
0245 120000      E     LCALL   _lis2dh_RegRead
                                           ; SOURCE LINE # 1268
0248 900000      R     MOV     DPTR,#lis2dh_FIFO_SRC_REG_value
024B E0                MOVX    A,@DPTR
024C 30E635            JNB     ACC.6,?C0135
                                           ; SOURCE LINE # 1270
024F E4                CLR     A
0250 FB                MOV     R3,A
0251 FD                MOV     R5,A
0252 FF                MOV     R7,A
0253 120000      E     LCALL   _lis2dh_configure_FIFO
                                           ; SOURCE LINE # 1271
0256 900000      E     MOV     DPTR,#?_lis2dh_Read_XYZ?BYTE+03H
0259 7401              MOV     A,#01H
025B F0                MOVX    @DPTR,A
025C A3                INC     DPTR
025D 7400        R     MOV     A,#HIGH gMockHID2Y
025F F0                MOVX    @DPTR,A
0260 A3                INC     DPTR
0261 7400        R     MOV     A,#LOW gMockHID2Y
0263 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 71  

0264 A3                INC     DPTR
0265 7401              MOV     A,#01H
0267 F0                MOVX    @DPTR,A
0268 A3                INC     DPTR
0269 7400        R     MOV     A,#HIGH gMockHID2Z
026B F0                MOVX    @DPTR,A
026C A3                INC     DPTR
026D 7400        R     MOV     A,#LOW gMockHID2Z
026F F0                MOVX    @DPTR,A
0270 7B01              MOV     R3,#01H
0272 7A00        R     MOV     R2,#HIGH gMockHID2X
0274 7900        R     MOV     R1,#LOW gMockHID2X
0276 120000      E     LCALL   _lis2dh_Read_XYZ
                                           ; SOURCE LINE # 1273
0279 7B1A              MOV     R3,#01AH
027B E4                CLR     A
027C FD                MOV     R5,A
027D 7F02              MOV     R7,#02H
027F 120000      E     LCALL   _lis2dh_configure_FIFO
                                           ; SOURCE LINE # 1280
0282 D2A2              SETB    Led1
                                           ; SOURCE LINE # 1283
                                           ; SOURCE LINE # 1299
                                           ; SOURCE LINE # 1300
0284         ?C0135:
0284 22                RET     
             ; FUNCTION readLIS2DH (END)

             ; FUNCTION _i2c_smbus_read_byte_data (BEGIN)
                                           ; SOURCE LINE # 1314
0000 900000      R     MOV     DPTR,#pRegValue
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EA                MOV     A,R2
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
;---- Variable 'regAddress' assigned to Register 'R5' ----
;---- Variable 'deviceAddress' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1315
                                           ; SOURCE LINE # 1321
000B 900000      R     MOV     DPTR,#gOffset
000E E0                MOVX    A,@DPTR
000F 2400        R     ADD     A,#LOW blockArr+04H
0011 F582              MOV     DPL,A
0013 E4                CLR     A
0014 3400        R     ADDC    A,#HIGH blockArr+04H
0016 F583              MOV     DPH,A
0018 ED                MOV     A,R5
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1330
001A EF                MOV     A,R7
001B 54FE              ANL     A,#0FEH
001D FF                MOV     R7,A
001E 7B01              MOV     R3,#01H
0020 7A00        R     MOV     R2,#HIGH blockArr
0022 7900        R     MOV     R1,#LOW blockArr
0024 900000      E     MOV     DPTR,#?_i2c_read?BYTE+04H
0027 7401              MOV     A,#01H
0029 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 72  

002A A3                INC     DPTR
002B F0                MOVX    @DPTR,A
002C 120000      E     LCALL   _i2c_read
                                           ; SOURCE LINE # 1335
002F 900000      R     MOV     DPTR,#gOffset
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 2400        R     ADD     A,#LOW blockArr
0036 F582              MOV     DPL,A
0038 E4                CLR     A
0039 3400        R     ADDC    A,#HIGH blockArr
003B F583              MOV     DPH,A
003D E0                MOVX    A,@DPTR
003E FE                MOV     R6,A
;---- Variable 'status' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 1336
003F 7400        R     MOV     A,#LOW blockArr+01H
0041 2F                ADD     A,R7
0042 F582              MOV     DPL,A
0044 E4                CLR     A
0045 3400        R     ADDC    A,#HIGH blockArr+01H
0047 F583              MOV     DPH,A
0049 E0                MOVX    A,@DPTR
004A FF                MOV     R7,A
;---- Variable 'regValue' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1350
004B EE                MOV     A,R6
004C 6003              JZ      ?C0136
                                           ; SOURCE LINE # 1351
004E 7FFF              MOV     R7,#0FFH
0050 22                RET     
                                           ; SOURCE LINE # 1352
0051         ?C0136:
                                           ; SOURCE LINE # 1354
0051 900000      R     MOV     DPTR,#pRegValue
0054 E0                MOVX    A,@DPTR
0055 FB                MOV     R3,A
0056 A3                INC     DPTR
0057 E0                MOVX    A,@DPTR
0058 FA                MOV     R2,A
0059 A3                INC     DPTR
005A E0                MOVX    A,@DPTR
005B F9                MOV     R1,A
005C 4A                ORL     A,R2
005D 6004              JZ      ?C0138
                                           ; SOURCE LINE # 1355
005F EF                MOV     A,R7
0060 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 1356
0063         ?C0138:
                                           ; SOURCE LINE # 1357
0063 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 1358
0065         ?C0137:
0065 22                RET     
             ; FUNCTION _i2c_smbus_read_byte_data (END)

             ; FUNCTION _i2c_smbus_write_byte_data (BEGIN)
                                           ; SOURCE LINE # 1414
;---- Variable 'deviceAddress' assigned to Register 'R7' ----
;---- Variable 'regValue' assigned to Register 'R3' ----
;---- Variable 'regAddress' assigned to Register 'R5' ----
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 73  

                                           ; SOURCE LINE # 1415
                                           ; SOURCE LINE # 1420
0000 AE05              MOV     R6,AR5
0002 900000      R     MOV     DPTR,#gOffset
0005 E0                MOVX    A,@DPTR
0006 FD                MOV     R5,A
0007 2400        R     ADD     A,#LOW blockArr+04H
0009 F582              MOV     DPL,A
000B E4                CLR     A
000C 3400        R     ADDC    A,#HIGH blockArr+04H
000E F583              MOV     DPH,A
0010 EE                MOV     A,R6
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1421
0012 7400        R     MOV     A,#LOW blockArr+05H
0014 2D                ADD     A,R5
0015 F582              MOV     DPL,A
0017 E4                CLR     A
0018 3400        R     ADDC    A,#HIGH blockArr+05H
001A F583              MOV     DPH,A
001C EB                MOV     A,R3
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1422
001E EF                MOV     A,R7
001F 54FE              ANL     A,#0FEH
0021 FF                MOV     R7,A
0022 7B01              MOV     R3,#01H
0024 7A00        R     MOV     R2,#HIGH blockArr
0026 7900        R     MOV     R1,#LOW blockArr
0028 900000      E     MOV     DPTR,#?_i2c_write?BYTE+04H
002B 7401              MOV     A,#01H
002D F0                MOVX    @DPTR,A
002E A3                INC     DPTR
002F F0                MOVX    @DPTR,A
0030 120000      E     LCALL   _i2c_write
                                           ; SOURCE LINE # 1427
0033 900000      R     MOV     DPTR,#gOffset
0036 E0                MOVX    A,@DPTR
0037 2400        R     ADD     A,#LOW blockArr
0039 F582              MOV     DPL,A
003B E4                CLR     A
003C 3400        R     ADDC    A,#HIGH blockArr
003E F583              MOV     DPH,A
0040 E0                MOVX    A,@DPTR
;---- Variable 'status' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1429
0041 6003              JZ      ?C0139
                                           ; SOURCE LINE # 1430
0043 7FFF              MOV     R7,#0FFH
0045 22                RET     
                                           ; SOURCE LINE # 1431
0046         ?C0139:
                                           ; SOURCE LINE # 1432
0046 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 1433
0048         ?C0140:
0048 22                RET     
             ; FUNCTION _i2c_smbus_write_byte_data (END)

             ; FUNCTION flash_Led1L_Led2L_100ms (BEGIN)
                                           ; SOURCE LINE # 1439
                                           ; SOURCE LINE # 1440
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 74  

                                           ; SOURCE LINE # 1441
0000 C2A2              CLR     Led1
                                           ; SOURCE LINE # 1442
0002 C2A1              CLR     Led2
                                           ; SOURCE LINE # 1443
0004 E4                CLR     A
0005 FF                MOV     R7,A
0006 120000      E     LCALL   _Timer0_Init
                                           ; SOURCE LINE # 1444
0009 7FC8              MOV     R7,#0C8H
000B 7E00              MOV     R6,#00H
000D 020000      E     LJMP    _T0_Wait
             ; FUNCTION flash_Led1L_Led2L_100ms (END)

             ; FUNCTION flash_Led1L_Led2H_100ms (BEGIN)
                                           ; SOURCE LINE # 1450
                                           ; SOURCE LINE # 1451
                                           ; SOURCE LINE # 1452
0000 C2A2              CLR     Led1
                                           ; SOURCE LINE # 1453
0002 D2A1              SETB    Led2
                                           ; SOURCE LINE # 1454
0004 E4                CLR     A
0005 FF                MOV     R7,A
0006 120000      E     LCALL   _Timer0_Init
                                           ; SOURCE LINE # 1455
0009 7FC8              MOV     R7,#0C8H
000B 7E00              MOV     R6,#00H
000D 020000      E     LJMP    _T0_Wait
             ; FUNCTION flash_Led1L_Led2H_100ms (END)

             ; FUNCTION flash_Led1H_Led2L_100ms (BEGIN)
                                           ; SOURCE LINE # 1461
                                           ; SOURCE LINE # 1462
                                           ; SOURCE LINE # 1463
0000 D2A2              SETB    Led1
                                           ; SOURCE LINE # 1464
0002 C2A1              CLR     Led2
                                           ; SOURCE LINE # 1465
0004 E4                CLR     A
0005 FF                MOV     R7,A
0006 120000      E     LCALL   _Timer0_Init
                                           ; SOURCE LINE # 1466
0009 7FC8              MOV     R7,#0C8H
000B 7E00              MOV     R6,#00H
000D 020000      E     LJMP    _T0_Wait
             ; FUNCTION flash_Led1H_Led2L_100ms (END)

             ; FUNCTION flash_Led1H_Led2H_100ms (BEGIN)
                                           ; SOURCE LINE # 1472
                                           ; SOURCE LINE # 1473
                                           ; SOURCE LINE # 1474
0000 D2A2              SETB    Led1
                                           ; SOURCE LINE # 1475
0002 D2A1              SETB    Led2
                                           ; SOURCE LINE # 1476
0004 E4                CLR     A
0005 FF                MOV     R7,A
0006 120000      E     LCALL   _Timer0_Init
                                           ; SOURCE LINE # 1477
0009 7FC8              MOV     R7,#0C8H
000B 7E00              MOV     R6,#00H
C51 COMPILER V9.51   F3XX_USB0_REPORTHANDLER                                               06/26/2015 13:32:25 PAGE 75  

000D 020000      E     LJMP    _T0_Wait
             ; FUNCTION flash_Led1H_Led2H_100ms (END)

             ; FUNCTION flash_Led1Led2_East (BEGIN)
                                           ; SOURCE LINE # 1482
                                           ; SOURCE LINE # 1483
                                           ; SOURCE LINE # 1484
0000 120000      R     LCALL   flash_Led1H_Led2H_100ms
                                           ; SOURCE LINE # 1485
0003 120000      R     LCALL   flash_Led1L_Led2H_100ms
                                           ; SOURCE LINE # 1486
0006 120000      R     LCALL   flash_Led1L_Led2L_100ms
                                           ; SOURCE LINE # 1487
0009 120000      R     LCALL   flash_Led1H_Led2L_100ms
                                           ; SOURCE LINE # 1488
000C 020000      R     LJMP    flash_Led1H_Led2H_100ms
             ; FUNCTION flash_Led1Led2_East (END)

             ; FUNCTION flash_Led1Led2_Blink (BEGIN)
                                           ; SOURCE LINE # 1493
                                           ; SOURCE LINE # 1494
                                           ; SOURCE LINE # 1495
0000 120000      R     LCALL   flash_Led1H_Led2H_100ms
                                           ; SOURCE LINE # 1496
0003 120000      R     LCALL   flash_Led1L_Led2L_100ms
                                           ; SOURCE LINE # 1497
0006 020000      R     LJMP    flash_Led1H_Led2H_100ms
             ; FUNCTION flash_Led1Led2_Blink (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3829    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    218      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  11 WARNING(S),  0 ERROR(S)
